======================================
Chapter 8: Advanced views and URLconfs
======================================

In Chapter 3, we explained the basics of Django view functions and URLconfs.
This chapter goes into more detail about advanced functionality in those two
pieces of the framework.

URLconf tricks
==============

Streamlining function imports
-----------------------------

Consider this URLconf, which builds on the example in Chapter 3::

    from django.conf.urls.defaults import *
    from mysite.views import current_datetime, hours_ahead, hours_behind, now_in_chicago, now_in_london

    urlpatterns = patterns('',
        (r'^now/$', current_datetime),
        (r'^now/plus(\d{1,2})hours/$', hours_ahead),
        (r'^now/minus(\d{1,2})hours/$', hours_behind),
        (r'^now/in_chicago/$', now_in_chicago),
        (r'^now/in_london/$', now_in_london),
    )

As explained in Chapter 3, each entry in the URLconf includes its associated
view function, passed directly as a function object. This means it's necessary
to import the view functions at the top of the module.

But as a Django application grows in complexity, its URLconf grows, too, and
keeping those imports can be tedious to manage. (For each new view function,
you've got to remember to import it, and the import statement tends to get
overly long if you use this approach.) It's possible to avoid that tedium by
importing the ``views`` module itself. This example URLconf is equivalent to
the previous one::

    from django.conf.urls.defaults import *
    from mysite import views

    urlpatterns = patterns('',
        (r'^now/$', views.current_datetime),
        (r'^now/plus(\d{1,2})hours/$', views.hours_ahead),
        (r'^now/minus(\d{1,2})hours/$', views.hours_behind),
        (r'^now/in_chicago/$', views.now_in_chicago),
        (r'^now/in_london/$', views.now_in_london),
    )

Django offers another way of specifying the view function for a particular
pattern in the URLconf: You can pass a string containing the module name and
function name rather than the function object itself. Continuing the ongoing
example::

    from django.conf.urls.defaults import *

    urlpatterns = patterns('',
        (r'^now/$', 'mysite.views.current_datetime'),
        (r'^now/plus(\d{1,2})hours/$', 'mysite.views.hours_ahead'),
        (r'^now/minus(\d{1,2})hours/$', 'mysite.views.hours_behind'),
        (r'^now/in_chicago/$', 'mysite.views.now_in_chicago'),
        (r'^now/in_london/$', 'mysite.views.now_in_london'),
    )

Using this technique, it's no longer necessary to import the view functions;
Django automatically imports the appropriate view function the first time it's
needed, according to the string describing the name and path of the view
function.

A further shortcut you can take when using the string technique is to factor
out a common "view prefix." In our URLconf example, each of the view strings
starts with ``'mysite.views'``, which is redundant to type. We can factor out
that common prefix and pass it as the first argument to ``patterns()``, like
this::

    from django.conf.urls.defaults import *

    urlpatterns = patterns('mysite.views',
        (r'^now/$', 'current_datetime'),
        (r'^now/plus(\d{1,2})hours/$', 'hours_ahead'),
        (r'^now/minus(\d{1,2})hours/$', 'hours_behind'),
        (r'^now/in_chicago/$', 'now_in_chicago'),
        (r'^now/in_london/$', 'now_in_london'),
    )

Note that you don't put a trailing dot (``"."``) in the prefix, nor do you put
a leading dot in the view strings. Django knows what to do automatically.

With these two approaches in mind, which is better? It really depends on your
personal coding style and needs.

Advantages of the string approach are:

    * It's more compact, because it doesn't require you to import the view
      functions.

    * It results in more readable and manageable URLconfs if your view
      functions are spread across several different Python modules.

Advantages of the function object approach are:

    * It allows for easy "wrapping" of view functions. See "Wrapping view
      functions" later in this chapter.

    * It's more "Pythonic" -- that is, it's more in line with the Python
      tradition of passing functions as objects.

Both approaches are valid, and you can even mix and match them within the same
URLconf. The choice is yours.

Multiple view prefixes
----------------------

In practice, if you use the string technique, you'll probably end up mixing and
matching views to the point where the views in your URLconf won't have a common
prefix. However, you can still take advantage of the view prefix shortcut to
remove duplication. Just add multiple ``patterns()`` objects together, like
this:

Old::

    from django.conf.urls.defaults import *

    urlpatterns = patterns('',
        (r'^/?$', 'mysite.views.archive_index'),
        (r'^(\d{4})/([a-z]{3})/$', 'mysite.views.archive_month'),
        (r'^tag/(\w+)/$', 'weblog.views.tag'),
    )

New::

    from django.conf.urls.defaults import *

    urlpatterns = patterns('mysite.views',
        (r'^/?$', 'archive_index'),
        (r'^(\d{4})/([a-z]{3})/$','archive_month'),
    )

    urlpatterns += patterns('weblog.views',
        (r'^tag/(\w+)/$', 'tag'),
    )

Named groups
------------

In all of our URLconf examples so far, we've used simple, *non-named*
regular-expression groups -- i.e., we've put parentheses around parts of the
URL we wanted to capture, and Django passes that captured text to the view
function as a positional argument. In more advanced usage, it's possible to use
*named* regular-expression groups to capture URL bits and pass them as
*keyword* arguments to a view.

In Python regular expressions, the syntax for named regular-expression groups
is ``(?P<name>pattern)``, where ``name`` is the name of the group and
``pattern`` is some pattern to match.

Here's an example URLconf that uses nonnamed groups::

    from django.conf.urls.defaults import *
    from mysite import views

    urlpatterns = patterns('',
        (r'^articles/(\d{4})/$', views.year_archive),
        (r'^articles/(\d{4})/(\d{2})/$', views.month_archive),
    )

Here's the same URLconf, rewritten to use named groups::

    from django.conf.urls.defaults import *
    from mysite import views

    urlpatterns = patterns('',
        (r'^articles/(?P<year>\d{4})/$', views.year_archive),
        (r'^articles/(?P<year>\d{4})/(?P<month>\d{2})/$', views.month_archive),
    )

This accomplishes exactly the same thing as the previous example, with one
subtle difference: The captured values are passed to view functions as keyword
arguments rather than positional arguments.

For example, with nonnamed groups, a request to ``/articles/2006/03/`` would
result in a function call equivalent to this::

    month_archive(request, '2006', '03')

With named groups, though, the same request would result in this function call::

    month_archive(request, year='2006', month='03')

In practice, using named groups makes your URLconfs slightly more explicit and
less prone to argument-order bugs -- and you can reorder the arguments in your
views' function definitions. Following the above example, if we wanted to
change the URLs to contain the month *before* the year, and we were using
nonnamed groups, we'd have to remember to change the order of arguments in the
``month_archive`` view. If we were using named groups, changing the order of
the captured parameters in the URL would have no effect on the view.

Of course, the benefits of named groups come at the cost of brevity; some
developers find the named-group syntax ugly and too verbose.
















Positional vs. keyword arguments to views

Raising 404

Default arguments to views

The matching/grouping algorithm

What the URLconf searches against

Including other URLconfs
Passing extra options to include()

Notes on capturing text in URLs

The view prefix
Multiple view prefixes

Strings vs. view objects in the URLconf

