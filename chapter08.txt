=============
Generic views
=============

Here again is a recurring theme of this book: at it worst web development is
boring and monotonous. So far you've seen how Django tries to take away some
of that monotony at the model and template layers, but web developers also
experience this boredom at the view level.

Django's **generic views** were to developed to ease that pain. They take
certain common idioms and patterns in view development and abstract them so
that you can quickly write common views of onto data without having to write
too much code.

In fact, nearly every example in the preceeding chapters could be re-written
with the help of generic views.

Django contains generic views to do the following:

    * Perform common "simple" tasks: redirect to a different page, and 
      render a given template.

    * Display list and detail pages for a single object. For example, the
      Django documentation index
      (http://www.djangoproject.com/documentation/) and individual
      document pages are built this way. The crime index and list of
      crimes by type views from Chapter 5 could easily be re-written to
      use generic views; we'll do so below.

    * Present date-based objects in year/month/day archive pages,
      associated detail and "latest" pages.  The Django weblog's
      (http://www.djangoproject.com/weblog/) year, month, and
      day archives are built with these, as are ljworld.com's
      news archives, and a whole host of others.

    * Allow users to create, update, and delete objects -- with or
      without authorization.  We'll show how to replace the views
      from Chapter 7 with these views below.

Taken together, these views provide easy interfaces to perform the most common tasks we encounter.

Using generic views
===================

All of these views are used by creating configuration dictionaries in
your URLconf files and passing those dictionaries as the third member of the
URLconf tuple for a given pattern. 

For example, here's the URLconf for the simple weblog app that drives the blog
on djangoproject.com::

    from django.conf.urls.defaults import *
    from django_website.apps.blog.models import Entry

    info_dict = {
        'queryset': Entry.objects.all(),
        'date_field': 'pub_date',
    }

    urlpatterns = patterns('django.views.generic.date_based',
       (r'^(?P<year>\d{4})/(?P<month>[a-z]{3})/(?P<day>\w{1,2})/(?P<slug>[-\w]+)/$', 'object_detail', dict(info_dict, slug_field='slug')),
       (r'^(?P<year>\d{4})/(?P<month>[a-z]{3})/(?P<day>\w{1,2})/$',                  'archive_day',   info_dict),
       (r'^(?P<year>\d{4})/(?P<month>[a-z]{3})/$',                                   'archive_month', info_dict),
       (r'^(?P<year>\d{4})/$',                                                       'archive_year',  info_dict),
       (r'^/?$',                                                                     'archive_index', info_dict),
    )

As you can see, this URLconf defines a few options in ``info_dict``.
``'queryset'`` gives the generic view a ``QuerySet`` of objects to use (in
this case, all of the ``Entry`` objects) and tells the generic view which
model is being used.  The remaining arguments to each generic view are taken
from the named captures in the URLconf.

This is really all the "view" code for Django's weblog!  The only thing that's left 
is writing a template.

Documentation of each generic view follows, along with a list of all keyword
arguments that a generic view expects. Remember that as in the example above,
arguments may either come from the URL pattern (as ``month``, ``day``,
``year``, etc. do above) or from the additional-information dictionary (as for
``queryset``, ``date_field``, etc.).

Most generic views require the ``queryset`` key, which is a ``QuerySet``
instance; see the database API referenecce in Chapter XXX for more information
about ``QuerySet`` objects.

Most views also take an optional ``extra_context`` dictionary that you can use
to pass any auxiliary information you wish to the view. The values in the
``extra_context`` dictionary can be either functions (or other callables) or
other objects. Functions are evaluated just before they are passed to the
template.

"Simple" generic views
======================

The ``django.views.generic.simple`` module contains simple views to handle a
couple of common cases: rendering a template when no view logic is needed,
and issuing a redirect.

Rendering a template
--------------------

The function ``django.views.generic.simple.direct_to_template`` renders a
given template, passing it a ``{{ params }}`` template variable, which is a
dictionary of the parameters captured in the URL.

Example
```````

Given the following URL patterns::

    urlpatterns = patterns('django.views.generic.simple',
        (r'^foo/$',             'direct_to_template', {'template': 'foo_index.html'}),
        (r'^foo/(?P<id>\d+)/$', 'direct_to_template', {'template': 'foo_detail.html'}),
    )

a request to ``/foo/`` would render the template ``foo_index.html``, and a
request to ``/foo/15/`` would render the ``foo_detail.html`` with a context
variable ``{{ params.id }}`` that is set to ``15``.

Required arguments
``````````````````

    ``template``
        The full name of a template to use.

Redirecting to another URL
--------------------------

``django.views.generic.simple.redirect_to`` redirects to another URL.
The given URL may contain dictionary-style string formatting, which will be
interpolated against the parameters captured in the URL.

If the given URL is ``None``, Django will return an HTTP 410 (Gone) message.

Example
```````

This example redirects from ``/foo/<id>/`` to ``/bar/<id>/``::

    urlpatterns = patterns('django.views.generic.simple',
        ('^foo/(?p<id>\d+)/$', 'redirect_to', {'url': '/bar/%(id)s/'}),
    )

This example returns a 410 HTTP error for requests to ``/bar/``::

    urlpatterns = patterns('django.views.generic.simple',
        ('^bar/$', 'redirect_to', {'url': None}),
    )

Required arguments
``````````````````

    ``url``: 
        The URL to redirect to, as a string. Or ``None`` to raise a 410 (Gone)
        HTTP error.

List/detail generic views
=========================

The list-detail generic views (in the module
``django.views.generic.list_detail``) handles the common case of displaying a
list of items at one view, and individual "detail" views of those items at
another.

List views
----------

The view ``django.views.generic.list_detail.object_list`` is used to create a
page representing a list of objects.  

Example
```````

One view missing from the crime views developed in Chapter 5 is a simple list
of all crimes to stand alongside to the crimes-by-type view (which we'll get
to in a moment).  We can easily fill this gap with a generic view.

First, we'll need to construct a info dictionary for the generic view. Add the
following to the top of the ``myproject/crimes/urls.py`` file::

    from myproject.crimes.models import Crime

    crime_list_info = {
        'queryset' :   Crime.objects.all(),
        'allow_empty': True,
    }
    
Then, we need to register this view at a certain URL.  Add this to the bottom
of that same file::

    urlpatterns += patterns('django.views.generic.list_detail', 
        (r'^/crimes/all/$', 'object_list', crime_list_info),
    )

Required arguments
``````````````````

    * ``queryset``: A ``QuerySet`` of objects to list

Optional arguments
``````````````````

    ``allow_empty``
        A boolean specifying whether to display the page if no objects are
        available. If this is ``False`` and no objects are available, the view
        will raise a 404 instead of displaying an empty page. By default, this
        is ``False``.
    
    ``context_processors``
        A list of template-context processors to apply to the view's template.
        See Chapter XXX for information on template context processors.

    ``extra_context``
        A dictionary of values to add to the template context. By default,
        this is an empty dictionary. If a value in the dictionary is callable,
        the generic view will call it just before rendering the template.

    ``mimetype``
        The MIME type to use for the resulting document. Defaults to the value
        of the ``DEFAULT_MIME_TYPE`` setting.

    ``paginate_by``
        An integer specifying how many objects should be displayed per page.
        If this is given, the view will paginate objects with ``paginate_by``
        objects per page. The view will expect either a ``page`` query string
        parameter (via ``GET``) containing a zero-indexed page number, or a
        ``page`` variable specified in the URLconf. See "Notes on pagination"
        below.

    ``template_loader``
        The template loader to use when loading the template. By default, it's
        ``django.template.loader``.  See Chapter XXX for information on 
        template loaders.
    
    ``template_name``
        The full name of a template to use in rendering the page. This lets
        you override the default template name derrived from the ``QuerySet``
        (see below).
    
    ``template_object_name``
        Designates the name of the template variable to use in the template
        context. By default, this is ``'object'``. The view will append
        ``'_list'`` to the value of this parameter in determining the
        variable's name.

Template name
`````````````

If ``template_name`` isn't specified, this view will use the template
``<app_label>/<model_name>_list.html`` by default. Both the app label and the
model name are derived from the ``queryset`` parameter: the app label is the
name of the app that the model is defined in, and the model name is the
lower-cased version of the name of the model class.

So, if we passed ``Crime.objects.all()`` as the ``queryset``, the app label
would be ``crimes`` and the model name would be ``crime``. This means the
default template would be ``crimes/crime_list.html``.

Template context
````````````````

In addition to ``extra_context``, the template's context will be:

    * ``object_list``: The list of objects. This variable's name depends on the
      ``template_object_name`` parameter, which is ``'object'`` by default. If
      ``template_object_name`` is ``'foo'``, this variable's name will be
      ``foo_list``.

    * ``is_paginated``: A boolean representing whether the results are
      paginated. Specifically, this is set to ``False`` if the number of
      available objects is less than or equal to ``paginate_by``.

If the results are paginated, the context will contain these extra variables:

    * ``results_per_page``: The number of objects per page. (Same as the
      ``paginate_by`` parameter.)

    * ``has_next``: A boolean representing whether there's a next page.

    * ``has_previous``: A boolean representing whether there's a previous page.

    * ``page``: The current page number, as an integer. This is 1-based.

    * ``next``: The next page number, as an integer. If there's no next page,
      this will still be an integer representing the theoretical next-page
      number. This is 1-based.

    * ``previous``: The previous page number, as an integer. This is 1-based.

    * ``pages``: The total number of pages, as an integer.

    * ``hits``: The total number of objects across *all* pages, not just this
      page.

Notes on pagination
~~~~~~~~~~~~~~~~~~~

If ``paginate_by`` is specified, Django will paginate the results. You can
specify the page number in the URL in one of two ways:

    * Use the ``page`` parameter in the URLconf. For example, this is what
      your URLconf might look like::

        (r'^objects/page(?P<page>[0-9]+)/$', 'object_list', dict(info_dict))

    * Pass the page number via the ``page`` query-string parameter. For
      example, a URL would look like this:

        /objects/?page=3

In both cases, ``page`` is 1-based, not 0-based, so the first page would be
represented as page ``1``.

``django.views.generic.list_detail.object_detail``
--------------------------------------------------

A page representing an individual object.

**Description:**

A page representing an individual object.

**Required arguments:**

    * ``queryset``: A ``QuerySet`` that contains the object.

    * Either ``object_id`` or (``slug`` *and* ``slug_field``) is required.

      If you provide ``object_id``, it should be the value of the primary-key
      field for the object being displayed on this page.

      Otherwise, ``slug`` should be the slug of the given object, and
      ``slug_field`` should be the name of the slug field in the ``QuerySet``'s
      model.

**Optional arguments:**

    * ``template_name``: The full name of a template to use in rendering the
      page. This lets you override the default template name (see below).

    * ``template_name_field``: The name of a field on the object whose value is
      the template name to use. This lets you store template names in the data.
      In other words, if your object has a field ``'the_template'`` that
      contains a string ``'foo.html'``, and you set ``template_name_field`` to
      ``'the_template'``, then the generic view for this object will use the
      template ``'foo.html'``.

      It's a bit of a brain-bender, but it's useful in some cases.

    * ``template_loader``: The template loader to use when loading the
      template. By default, it's ``django.template.loader``.

    * ``extra_context``: A dictionary of values to add to the template
      context. By default, this is an empty dictionary. If a value in the
      dictionary is callable, the generic view will call it
      just before rendering the template.

    * ``context_processors``: A list of template-context processors to apply to
      the view's template. See the `RequestContext docs`_.

    * ``template_object_name``:  Designates the name of the template variable
       to use in the template context. By default, this is ``'object'``.

    * ``mimetype``: The MIME type to use for the resulting document. Defaults
      to the value of the ``DEFAULT_MIME_TYPE`` setting.

**Template name:**

If ``template_name`` isn't specified, this view will use the template
``<app_label>/<model_name>_detail.html`` by default.

**Template context:**

In addition to ``extra_context``, the template's context will be:

    * ``object``: The object. This variable's name depends on the
      ``template_object_name`` parameter, which is ``'object'`` by default. If
      ``template_object_name`` is ``'foo'``, this variable's name will be
      ``foo``.
