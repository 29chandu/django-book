================
Chapter 5: Views
================

(This chapter has been superceded by chapter 3. This document still exists
because there might be some stuff in here that we want to save.)




.. Much of this chapter comes from the third Django tutorial (tutorial03.txt)

This is where it gets really interesting.

Up until this point, we've been dealing with how Django simplifies the boring,
annoying, repetitive tasks every web developer faces. Now that we've gotten
them out of the way, we can finally deal with the exciting, fun part of web
development: creating the public facing views.

.. note::

    We refer to views your write yourself as "public views" to differentiate
    them from the built-in admin interface, but really these "public" views
    could be anywhere on the spectrum of private-only-for-a-single-user to
    completely public world-accessibly websites.

This is also the point where Django philosophy of "getting out of your way"
comes into play: when writing views, you're pretty much left to your own
devices as Django tries to be as unobtrusive as possible.

.. admonition:: A note to the lazy

    Much of what we'll cover in this chapter can actually be done quicker and
    with less code using a feature called **Generic Views**, covered in
    Chapter 9. We're presenting this material first since we think a strong
    understanding of how to write your own views is very important -- you have
    to walk before you can run.

    However, as laziness is one of the cardinal virtues of the programmer (http://www.brainyquote.com/quotes/quotes/l/larrywall141510.html), 
    we won't be offended if you skip ahead and come back
    when you need a deeper understanding of exactly how views work.

Philosophy
==========

A view is a "type" of Web page in your Django application that generally
serves a specific function and has a specific template. For example, in a
weblog application, you might have the following views:

    * Blog homepage -- displays the latest few entries.

    * Entry "detail" page -- permalink page for a single entry.

    * Year-based archive page -- displays all months with entries in the
      given year.

    * Month-based archive page -- displays all days with entries in the
      given month.

    * Day-based archive page -- displays all entries in the given day.

    * Comment action -- handles posting comments to a given entry.

In our simplistic crime database example, we'll want a few views:

    * A "home page" showing the most recent crimes in the database and
      a list of all available crime types.

    * A list of crimes by type -- one page for each type of crime.

    * A detailed view of each crime.

(We'll also extend this short list in Chapter 7 by adding forms for readers to
submit corrections and/or additional information for each crime.)

In essence, a view is responsible for pulling together all the information
accessible at a given URL. It's where you look up data from a database, read
it in from a file, aggregate or summarize it, etc. Note that a view is *not*
where you define how this data *looks*; that's up to a template, which we'll
cover in the next chapter.

Design your URLs
================

The first step of writing views is to design your URL structure. You do this
by creating a Python module, called a **URLconf**. URLconfs are how Django
associates a given URL with given Python code.

When a user requests a Django-powered page, the system looks at the
``ROOT_URLCONF`` setting, which contains a string in Python dotted syntax.
Django loads that module and looks for a module-level variable called
``urlpatterns``, which is a sequence of tuples in the following format::

    (regular expression, Python callback function [, optional dictionary])

Django starts at the first regular expression and makes its way down the list,
comparing the requested URL against each regular expression until it finds one
that matches.

When it finds a match, Django calls the Python callback function with an
``HTTPRequest`` object as the first argument.  Django also passes keyword 
arguments for any "captured" values from the regular expression as well as 
items from the optional URLconf tuple dictionary.

For more on ``HTTPRequest`` objects, see Chapter XXX, and for more details on
URLconfs, see Chapter XXX.

When you ran ``django-admin.py startproject mysite`` at the beginning of
Chapter 2, it created a default URLconf in ``mysite/urls.py``. It also
automatically set your ``ROOT_URLCONF`` setting to point at that file::

    ROOT_URLCONF = 'mysite.urls'

Let's dive into writing views by editing ``myproject/urls.py`` so it looks like 
this::

    from django.conf.urls.defaults import *

    urlpatterns = patterns('',
        (r'^crimes/$', 'mysite.crimes.views.index'),
        (r'^crimes/types/(?P<type_id>\d+)/$', 'mysite.crimes.views.crimes_by_type'),
        (r'^crimes/detail/(?P<crime_id>\d+)/$', 'mysite.crimes.views.detail'),
    )
    
..  XXX JGD probably should indicate that the admin tuple previously included is not 
to be removed.    

This is worth a review. When somebody requests a page from your Web site --
say, "/crimes/detail/44/", Django will load this Python module, because it's
pointed to by the ``ROOT_URLCONF`` setting.

Django then finds the variable named ``urlpatterns`` and traverses the regular
expressions in order. When it finds a regular expression that matches --
``r'^crimes/detail/(?P<crime_id>\d+)/$'`` -- it loads the associated Python
package/module: ``myproject.crimes.views.detail``. That corresponds to
the function ``detail()`` in ``mysite/crimes/views.py``. Finally, it
calls that ``detail()`` function like so::

    detail(request=<HttpRequest object>, crime_id='44')

The ``crime_id='44'`` part comes from ``(?P<crime_id>\d+)``. Using parenthesis
around a pattern "captures" the text matched by that pattern and sends it as
an argument to the view function; the ``?P<crime_id>`` defines the name that
will be used to identify the matched pattern; and ``\d+`` is a regular
expression to match a sequence of digits (i.e., a number).

Because the URL patterns are regular expressions, there really is no limit on
what you can do with them. And there's no need to add URL cruft such as
``.php`` -- unless you have a sick sense of humor, in which case you can do
something like this::

    (r'^crimes/latest\.php$', 'mysite.crimes.views.index'),

But, don't do that. It's silly.

Note that these regular expressions do not search GET and POST parameters, or
the domain name. For example, when servicing requests for both
``http://www.example.com/myapp/`` and ``http://www.example.com/myapp/?page=3``, 
Django will attempt to match ``/myapp/``.


If you need help with regular expressions, see Wikipedia's entry
(http://en.wikipedia.org/wiki/Regular_expression) and the Python documentation
(http://www.python.org/doc/current/lib/module-re.html). Also, the O'Reilly
book "Mastering Regular Expressions" by Jeffrey Friedl is fantastic.

.. Are we "allowed" to pimp non-Apress books? <grin>

Finally, a performance note: these regular expressions are compiled the first
time the URLconf module is loaded so they're super fast.

Write your first view
=====================

At this point we've not actually created any views -- we just have the
URLconf. But let's make sure Django is following the URLconf properly.

Fire up the Django development Web server::

    python manage.py runserver

Now go to "http://localhost:8000/crimes/" on your domain in your Web browser.
You should get a pleasantly-colored error page::

.. image:: images/chapter05/crime_view_does_not_exist.png

This error happened because you haven't written a function ``index()`` in the
module ``mysite/crimes/views.py``.

Try "/crimes/detail/23/", "/crimes/types/44/" and "/salmon/". The first two
error messages show look the same and will tell you which view Django tried
(and failed to find, because you haven't written any views yet).

The third URL -- ``/salmon/`` -- will give you a different error, Django's
version of a HTTP 404 page::

.. image:: images/chapter05/404.png

This is because no patterns match the URL you've given Django, and so it tells you so.

.. note::

    These "pretty" error pages show up because you have ``DEBUG = True`` in
    your settings file. Once you actually deploy a site, change ``DEBUG`` to
    ``False``.  This will replace these developer-friendly error pages with simple
    error pages that don't reveal any potentially dangerous information about
    your site, as well as improve performance by leaving out some 
    developer-specific functionality.
    

OK, time to write our first view.. Open the file ``mysite/crimes/views.py``
and put the following Python code in it::

    from django.http import HttpResponse

    def index(request):
        return HttpResponse("Hello, world. You're at the crime index.")

This is the simplest view possible. Go to "/crimes/" in your browser, and you
should see your text.

.. note::

    Django's development server automatically reloads your code when you
    make any changes to it; you don't have to restart the server.  However,
    this reloading process can take a second or two.  So if you see a 
    "server is not responding" message in your browser just wait a second
    and try again.

Now add the following view. It's slightly different -- it takes an
argument (which, remember, is passed in from whatever was captured by the
regular expression in the URLconf)::

    def detail(request, crime_id):
        return HttpResponse("You're looking at crime %s." % crime_id)

Take a look in your browser, at "/crimes/detail/34/". It'll display whatever
ID you provide in the URL.

Write views that actually do something
======================================

Each view is responsible for doing one of two things: Returning an
``HttpResponse`` object containing the content for the requested page, or
raising an exception such as ``Http404``. The rest is up to you.

Your view can read records from a database, or not. It can use a template
system such as Django's -- or a third-party Python template system -- or not.
It can generate a PDF file, output XML, create a ZIP file on the fly, anything
you want, using whatever Python libraries you want.

All Django wants is that ``HttpResponse``. Or an exception.

Because it's convenient, let's use Django's own database API, which we covered
in Chapter 3. Here's one stab at the ``index()`` view, which displays the
latest 10 crime locations in the system, according to
when the crimes occurred::

    from crimes.models import Crime 

    def index(request):
        latest_crime_list = Crime.objects.all().order_by('-when')[:10]
        output = "<ul>"
        for crime in latest_crime_list:
            output += "<li>Crime: %s at %s [%s]" % \
                (crime.type, crime.location, crime.when)
        output += "</ul>"
        return HttpResponse(output)

There's a problem here, though. The page's design is hard-coded in the view.
If you want to change the way the page looks, you'll have to edit this Python
code. This is why Django includes a template system to separate the design from
Python::

    from django.template import loader, context
    from crimes.models import Crime
    from django.http import HttpResponse

    def index(request):
        latest_crime_list = Crime.objects.all().order_by('-when')[:10]
        t = loader.get_template('crimes/index.html')
        c = context.Context({
            'latest_crime_list': latest_crime_list,
        })
        return HttpResponse(t.render(c))

That code will a template called "crimes/index.html" and render a paged based on a
context. The context is a dictionary which maps template variable names to Python
objects.

Reload the page. Now you'll see an error::

.. image:: images/chapter05/missing_crime_index_template.png

Ah. There's no template yet. First, create a directory, somewhere on your
filesystem, whose contents Django can access. (Django runs as the same user
as your web server.)  It doesn't really matter where these templates live; one
good place inside the ``myproject`` directory.

Now edit ``TEMPLATE_DIRS`` in your ``settings.py`` to tell Django where it
can find templates -- just as you did in the "Customize the admin look and
feel" section of Chapter 4.

When you've done that, create a directory ``crimes`` in your template
directory. Within that, create a file called ``index.html``.   The line::

    template.loader.get_template('crimes/index.html')

from above loads the template from ``<template_directory>/crimes/index.html`` 
by using the filesystem template loader.  For more details, see Chapter XXX.


Put this code in that template::

    {% if latest_crime_list %}
        <ul>
        {% for crime in latest_crime_list %}
            <li>{{ crime.type }} at {{ crime.location }}
                [{{ crime.when }}]</li>
        {% endfor %}
        </ul>
    {% else %}
        <p>No crimess are available.</p>
    {% endif %}

Load the page in your Web browser, and you should see a bulleted-list of any
crimes you've entered into the database.

For the moment, don't worry too much about the template syntax; we'll cover it
in detail in the next chapter.  What's important to notice now is that the
template system uses dot-lookup syntax to access variable attributes. In the
example of ``{{ crime.location }}``, first Django does a dictionary lookup for 
``location`` on the ``crime`` object. Failing that, it tries attribute lookup 
-- which works, in this case. If attribute lookup had failed, it would've tried 
calling the method ``location()``.

Also notice that Django automatically follows the relationship to ``type``
when you say ``{{ crime.type }}``, and converts the ``CrimeType`` object to a
string using the ``__str__`` method we defined in Chapter 3.

We'll let the rest of this template remain a bit of a mystery until the next chapter.

A shortcut: render_to_response()
--------------------------------

It's a very common idiom to load a template, fill a context and return an
``HttpResponse`` object with the result of the rendered template. Django
provides a shortcut. Here's the full ``index()`` view, rewritten::

    from django.shortcuts import render_to_response
    from mysite.crimes.models import Crime

    def index(request):
        latest_crime_list = Crime.objects.all().order_by('-when')[:10]
        return render_to_response('crimes/index.html', {
            'latest_crime_list': latest_crime_list
        })

Note that we no longer need to import ``loader``, ``Context`` or
``HttpResponse``.

The ``render_to_response()`` function takes a template name as its first
argument and a dictionary as its optional second argument. It returns an
``HttpResponse`` object of the given template rendered with the given context.

Raising 404
===========

Now, let's tackle the crime detail view -- the page that displays detailed
information for a single crime::

    from django.http import Http404
    from django.shortcuts import render_to_response
    from crimes.models import Crime

    def detail(request, crime_id):
        try:
            c = Crime.objects.get(pk=crime_id)
        except Crime.DoesNotExist:
            raise Http404
        return render_to_response('crimes/detail.html', {'crime': c})

The new concept here: The view raises the ``django.http.Http404``
exception if a crime with the requested ID doesn't exist.

A shortcut: get_object_or_404()
-------------------------------

It's a very common idiom to use ``get_object()`` and raise ``Http404`` if the
object doesn't exist. Again, Django provides a shortcut for this idiom..
Here's the ``detail()`` view, rewritten::

    from django.shortcuts import render_to_response, get_object_or_404
    from mysite.crimes.models import Crime

    def detail(request, crime_id):
        c = get_object_or_404(Crime, pk=crime_id)
        return render_to_response('crimes/detail.html', {'crime': c})

The ``get_object_or_404()`` function takes a Django model module as its first
argument and an arbitrary number of keyword arguments, which it passes to the
module's ``get_object()`` function. It raises ``Http404`` if the object
doesn't exist.

.. admonition:: Philosophy

    Why do we use a helper function ``get_object_or_404()`` instead of
    automatically catching the ``DoesNotExist`` exceptions at a higher level,
    or having the model API raise ``Http404`` instead of ``DoesNotExist``?

    Because that would couple the model layer to the view layer. One of the
    foremost design goals of Django is to maintain loose coupling; since
    models can be used in many other places besides service web requests,
    they shouldn't have to know details about HTTP including the 404 error 
    code.
    

There's also a ``get_list_or_404()`` function, which works just as
``get_object_or_404()`` -- except using ``get_list()`` instead of
``get_object()``. It raises ``Http404`` if the list is empty.

Write a 404 (page not found) view
=================================

When you raise ``Http404`` from within a view, Django will load a special view
devoted to handling 404 errors. It finds it by looking for the variable
``handler404``, which is a string in Python dotted syntax -- the same format
the normal URLconf callbacks use. A 404 view itself has nothing special: It's
just a normal view.

You normally won't have to bother with writing 404 views. By default, URLconfs
have the following line up top::

    from django.conf.urls.defaults import *

That takes care of setting ``handler404`` in the current module. As you can
see in ``django/conf/urls/defaults.py``, ``handler404`` is set to
``'django.views.defaults.page_not_found'`` by default.

Three more things to note about 404 views:

    * The 404 view is also called if Django doesn't find a match after
      checking every regular expression in the URLconf.

    * If ``DEBUG`` is set to ``True`` (in your settings module) then your 404
      view will never be used, and the traceback will be displayed instead.
    
    * If you don't define your own 404 view -- and simply use the default,
      which is recommended -- you still have one obligation: To create a
      ``404.html`` template in the root of your template directory. The
      default 404 view will use that template for all 404 errors.

.. XXX JGD It might be good, here, to show the error that occurs when a template 
doesn't exist: TemplateDoesNotExist: 404.html
     
Write a 500 (server error) view
===============================

Similarly, URLconfs may define a ``handler500``, which points to a view to
call in case of server errors. Server errors happen when you have runtime
errors in view code. Also like the 404 view, you'll want to create a
``500.html`` template for public consumption when ``DEBUG`` is off.

Use the template system
=======================

Back to our crime detail view.  Here's what the ``crimes/detail.html`` template might look like::

    <ul>
        <li>What: {{ crime.type }}</li>
        <li>When: {{ crime.when }}</li>
        <li>Where: {{ crime.location }}</li>
    </ul>

Simplifying the URLconfs
========================

Take some time to play around with the views and template system. As you edit
the URLconf, you may notice there's a fair bit of redundancy in it::

    from django.conf.urls.defaults import *

    urlpatterns = patterns('',
        (r'^crimes/$', 'mysite.crimes.views.index'),
        (r'^crimes/types/(?P<type_id>\d+)/$', 'mysite.crimes.views.crimes_by_type'),
        (r'^crimes/detail/(?P<crime_id>\d+)/$', 'mysite.crimes.views.detail'),
    )

Namely, ``mysite.crimes.views`` is in every callback.

Because this is a common case, the URLconf framework provides a shortcut for
common prefixes. You can factor out the common prefixes and add them as the
first argument to ``patterns()``, like so::

    urlpatterns = patterns('mysite.crimes.views',
        (r'^crimes/$', 'index'),
        (r'^crimes/types/(?P<type_id>\d+)/$', 'crimes_by_type'),
        (r'^crimes/detail/(?P<crime_id>\d+)/$', 'detail'),
    )

.. XXX JGD The prefix doesn't work if the user still has r'^admin/$' in their patterns.

.. XXX JGD Should probably mention (new) ability to pass callables instead of strings.


This is functionally identical to the previous formatting. It's just a bit
tidier, and if you ever decide to relocate those views into a different module
you've only got one line of code to change.

Decoupling the URLconfs
=======================

While we're at it, we should take the time to decouple our crime-app URLs from
our Django project configuration. Django apps are meant to be pluggable --
that is, each particular app should be transferrable to another Django
installation with minimal fuss.

Our crime app is pretty decoupled at this point, thanks to the strict
directory structure that ``python manage.py startapp`` created, but one part
of it is coupled to the Django settings: The URLconf.

We've been editing the URLs in ``mysite/urls.py``, but the URL design of an
app is specific to the app, not to the Django installation -- so let's move
the URLs within the app directory.

Copy the file ``myrpoject/urls.py`` to ``mysite/crimes/urls.py``. Then,
change ``mysite/urls.py`` to remove the crime-specific URLs and insert an
``include()``::

    (r'^crimes/', include('mysite.crimes.urls')),

``include()``, simply, references another URLconf. Note that the regular
expression doesn't have a ``$`` (end-of-string match character) but has the
trailing slash. Whenever Django encounters ``include()``, it chops off
whatever part of the URL matched up to that point and sends the remaining
string to the included URLconf for further processing.

Here's what happens if a user goes to "/crimes/detail/34/" in this system:

    * Django will find the match at ``'^crimes/'``

    * It will strip off the matching text (``"crimes/"``) and send the
      remaining text -- ``"detail/34/"`` -- to the 'mysite.crimes.urls'
      URLconf for further processing.

Now that we've decoupled that, we need to fix the 'mysite.crimes.urls'
urlconf by removing the leading "crimes/" from each line::

    urlpatterns = patterns('mysite.crimes.views',
        (r'^$', 'index'),
        (r'^types/(?P<type_id>\d+)/$', 'crimes_by_type'),
        (r'^detail/(?P<crime_id>\d+)/$', 'detail'),
    )

.. XXX JGD If we're talking about decoupling app from project, 
  shouldn't we also remove project name from app urls.py?
  This:
  (r'^crimes/', include('crimes.urls')),
  ...
  urlpatterns = patterns('crimes.views',
  not this:
  (r'^crimes/', include('myproject.crimes.urls'))
  ...
  urlpatterns = patterns('myproject.crimes.views',
  ?
  The former pair works for me...
  



The idea behind ``include()`` and URLconf decoupling is to make it easy to
plug-and-play URLs. Now that crimes are in their own URLconf, they can be
placed under "/crimes/", or under "/infractions/", or under
"/content/crimes/", or any other URL root, and the app will still work.

All the crime app cares about is its relative URLs, not its absolute URLs.

Wrapping up
===========

Let's wrap this up by finishing off all our views. So far we've written a
simple index and detail view, but not the ``crimes_by_type`` view. We also
wanted to show a list of all crime types on the index page. So, here's a
complete ``views.py`` with those changes that we'll carry into the next
chapter::

    from django.shortcuts import render_to_response, get_object_or_404
    from mysite.crimes.models import Crime, CrimeType

    def index(request):
        latest_crime_list = Crime.objects.all().order_by('-when')[:10]
        return render_to_response('crimes/index.html', {
            'latest_crime_list': latest_crime_list,
            'type_list': CrimeType.objects.all(),
        })

    def detail(request, crime_id):
        c = get_object_or_404(Crime, pk=crime_id)
        return render_to_response('crimes/detail.html', {'crime': c})

    def crimes_by_type(request, type_id):
        ct = get_object_or_404(CrimeType, pk=type_id)
        return render_to_response('crimes/crimes_by_type.html', {
            'crime_type' : ct
        })

        
.. XXX JGD There's no way for the user to test this (other than verifying no exception)
.. XXX JGD since the templates aren't updated to show the type_list and so on.
.. XXX JGD Perhaps it's better to just revise the views in the next chapter?        


What's next?
============

With those last few changes, our simple set of views is done. We've now
loaded all the data we want to present at each view, but we've only just
touched on how to format the data using the template system.

So, in the next chapter we'll finish the templates for these three views and
explain the template engine in all its glory.

Ready?