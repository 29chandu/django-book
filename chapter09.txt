========================
Chapter 9: Generic views
========================

.. contents::

Here again is a recurring theme of this book: at it worst web development is
boring and monotonous. So far you've seen how Django tries to take away some
of that monotony at the model and template layers, but web developers also
experience this boredom at the view level.

Django's **generic views** were to developed to ease that pain. They take
certain common idioms and patterns in view development and abstract them so
that you can quickly write common views of onto data without having to write
too much code.

In fact, nearly every example in the preceeding chapters could be re-written
with the help of generic views.

Django contains generic views to do the following:

    * Perform common "simple" tasks: redirect to a different page, and
      render a given template.

    * Display list and detail pages for a single object. For example, the
      Django documentation index
      (http://www.djangoproject.com/documentation/) and individual
      document pages are built this way. The crime index and list of
      crimes by type views from Chapter 5 could easily be re-written to
      use generic views; we'll do so below.

    * Present date-based objects in year/month/day archive pages,
      associated detail and "latest" pages.  The Django weblog's
      (http://www.djangoproject.com/weblog/) year, month, and
      day archives are built with these, as are ljworld.com's
      news archives, and a whole host of others.

    * Allow users to create, update, and delete objects -- with or
      without authorization.  We'll show how to replace the views
      from Chapter 7 with these views below.

Taken together, these views provide easy interfaces to perform the most common tasks we encounter.

Using generic views
===================

All of these views are used by creating configuration dictionaries in
your URLconf files and passing those dictionaries as the third member of the
URLconf tuple for a given pattern.

For example, here's the URLconf for the simple weblog app that drives the blog
on djangoproject.com::

    from django.conf.urls.defaults import *
    from django_website.apps.blog.models import Entry

    info_dict = {
        'queryset': Entry.objects.all(),
        'date_field': 'pub_date',
    }

    urlpatterns = patterns('django.views.generic.date_based',
       (r'^(?P<year>\d{4})/(?P<month>[a-z]{3})/(?P<day>\w{1,2})/(?P<slug>[-\w]+)/$', 'object_detail', dict(info_dict, slug_field='slug')),
       (r'^(?P<year>\d{4})/(?P<month>[a-z]{3})/(?P<day>\w{1,2})/$',                  'archive_day',   info_dict),
       (r'^(?P<year>\d{4})/(?P<month>[a-z]{3})/$',                                   'archive_month', info_dict),
       (r'^(?P<year>\d{4})/$',                                                       'archive_year',  info_dict),
       (r'^/?$',                                                                     'archive_index', info_dict),
    )

As you can see, this URLconf defines a few options in ``info_dict``.
``'queryset'`` gives the generic view a ``QuerySet`` of objects to use (in
this case, all of the ``Entry`` objects) and tells the generic view which
model is being used.  The remaining arguments to each generic view are taken
from the named captures in the URLconf.

This is really all the "view" code for Django's weblog!  The only thing that's left
is writing a template.

Documentation of each generic view follows, along with a list of all keyword
arguments that a generic view expects. Remember that as in the example above,
arguments may either come from the URL pattern (as ``month``, ``day``,
``year``, etc. do above) or from the additional-information dictionary (as for
``queryset``, ``date_field``, etc.).

Most generic views require the ``queryset`` key, which is a ``QuerySet``
instance; see the database API referenecce in Chapter XXX for more information
about ``QuerySet`` objects.

Most views also take an optional ``extra_context`` dictionary that you can use
to pass any auxiliary information you wish to the view. The values in the
``extra_context`` dictionary can be either functions (or other callables) or
other objects. Functions are evaluated just before they are passed to the
template.

"Simple" generic views
======================

The ``django.views.generic.simple`` module contains simple views to handle a
couple of common cases: rendering a template when no view logic is needed,
and issuing a redirect.

Rendering a template
--------------------

The function ``django.views.generic.simple.direct_to_template`` renders a
given template, passing it a ``{{ params }}`` template variable, which is a
dictionary of the parameters captured in the URL.

Example
```````

Given the following URL patterns::

    urlpatterns = patterns('django.views.generic.simple',
        (r'^foo/$',             'direct_to_template', {'template': 'foo_index.html'}),
        (r'^foo/(?P<id>\d+)/$', 'direct_to_template', {'template': 'foo_detail.html'}),
    )

a request to ``/foo/`` would render the template ``foo_index.html``, and a
request to ``/foo/15/`` would render the ``foo_detail.html`` with a context
variable ``{{ params.id }}`` that is set to ``15``.

Required arguments
``````````````````

    ``template``
        The full name of a template to use.

Redirecting to another URL
--------------------------

``django.views.generic.simple.redirect_to`` redirects to another URL.
The given URL may contain dictionary-style string formatting, which will be
interpolated against the parameters captured in the URL.

If the given URL is ``None``, Django will return an HTTP 410 (Gone) message.

Example
```````

This example redirects from ``/foo/<id>/`` to ``/bar/<id>/``::

    urlpatterns = patterns('django.views.generic.simple',
        ('^foo/(?p<id>\d+)/$', 'redirect_to', {'url': '/bar/%(id)s/'}),
    )

This example returns a 410 HTTP error for requests to ``/bar/``::

    urlpatterns = patterns('django.views.generic.simple',
        ('^bar/$', 'redirect_to', {'url': None}),
    )

Required arguments
``````````````````

    ``url``:
        The URL to redirect to, as a string. Or ``None`` to return a 410 (Gone)
        HTTP response.

List/detail generic views
=========================

The list-detail generic views (in the module
``django.views.generic.list_detail``) handles the common case of displaying a
list of items at one view, and individual "detail" views of those items at
another.

Lists of objects
----------------

The view ``django.views.generic.list_detail.object_list`` is used to create a
page representing a list of objects.

Example
```````

One view missing from the crime views developed in Chapter 5 is a simple list
of all crimes to stand alongside to the crimes-by-type view (which we'll get
to in a moment).  We can easily fill this gap with a generic view.

First, we'll need to construct a info dictionary for the generic view. Add the
following to the top of the ``mysite/crimes/urls.py`` file::

    from mysite.crimes.models import Crime

    crime_list_info = {
        'queryset' :   Crime.objects.all(),
        'allow_empty': True,
    }

Then, we need to register this view at a certain URL.  Add this to the bottom
of that same file::

    urlpatterns += patterns('django.views.generic.list_detail',
        (r'^/crimes/all/$', 'object_list', crime_list_info),
    )

Required arguments
``````````````````

    ``queryset``
        A ``QuerySet`` of objects to list

Optional arguments
``````````````````

    ``allow_empty``
        A boolean specifying whether to display the page if no objects are
        available. If this is ``False`` and no objects are available, the view
        will raise a 404 instead of displaying an empty page. By default, this
        is ``False``.

    ``context_processors``
        A list of template-context processors to apply to the view's template.
        See Chapter XXX for information on template context processors.

    ``extra_context``
        A dictionary of values to add to the template context. By default,
        this is an empty dictionary. If a value in the dictionary is callable,
        the generic view will call it just before rendering the template.

    ``mimetype``
        The MIME type to use for the resulting document. Defaults to the value
        of the ``DEFAULT_MIME_TYPE`` setting.

    ``paginate_by``
        An integer specifying how many objects should be displayed per page.
        If this is given, the view will paginate objects with ``paginate_by``
        objects per page. The view will expect either a ``page`` query string
        parameter (via ``GET``) containing a zero-indexed page number, or a
        ``page`` variable specified in the URLconf. See "Notes on pagination"
        below.

    ``template_loader``
        The template loader to use when loading the template. By default, it's
        ``django.template.loader``.  See Chapter XXX for information on
        template loaders.

    ``template_name``
        The full name of a template to use in rendering the page. This lets
        you override the default template name derrived from the ``QuerySet``
        (see below).

    ``template_object_name``
        Designates the name of the template variable to use in the template
        context. By default, this is ``'object'``. The view will append
        ``'_list'`` to the value of this parameter in determining the
        variable's name.

Template name
`````````````

If ``template_name`` isn't specified, this view will use the template
``<app_label>/<model_name>_list.html`` by default. Both the app label and the
model name are derived from the ``queryset`` parameter: the app label is the
name of the app that the model is defined in, and the model name is the
lower-cased version of the name of the model class.

So, if we passed ``Crime.objects.all()`` as the ``queryset``, the app label
would be ``crimes`` and the model name would be ``crime``. This means the
default template would be ``crimes/crime_list.html``.

Template context
````````````````

In addition to ``extra_context``, the template's context will contain:

    ``object_list``
        The list of objects. This variable's name depends on the
        ``template_object_name`` parameter, which is ``'object'`` by default.
        If ``template_object_name`` is ``'foo'``, this variable's name will be
        ``foo_list``.

    ``is_paginated``
        A boolean representing whether the results are paginated.
        Specifically, this is set to ``False`` if the number of available
        objects is less than or equal to ``paginate_by``.

If the results are paginated, the context will contain these extra variables:

    ``results_per_page``
        The number of objects per page. (Same as the ``paginate_by``
        parameter.)

    ``has_next``
        A boolean representing whether there's a next page.

    ``has_previous``
        A boolean representing whether there's a previous page.

    ``page``
        The current page number, as an integer. This is 1-based.

    ``next``
        The next page number, as an integer. If there's no next page, this
        will still be an integer representing the theoretical next-page
        number. This is 1-based.

    ``previous``
        The previous page number, as an integer. This is 1-based.

    ``pages``
        The total number of pages, as an integer.

    ``hits``
        The total number of objects across *all* pages, not just this page.

.. admonition:: A note on pagination:

    If ``paginate_by`` is specified, Django will paginate the results. You can
    specify the page number in the URL in one of two ways:

        * Use the ``page`` parameter in the URLconf. For example, this is what
          your URLconf might look like::

            (r'^objects/page(?P<page>[0-9]+)/$', 'object_list', dict(info_dict))

        * Pass the page number via the ``page`` query-string parameter. For
          example, a URL would look like this:

            /objects/?page=3

    In both cases, ``page`` is 1-based, not 0-based, so the first page would be
    represented as page ``1``.

Detail views
------------

The ``django.views.generic.list_detail.object_detail`` gives a "detail" view
of a single object.

Example
```````

Back in Chapter 5 we created a very simple crime detail view to display the
information about a particular ``Crime`` object.  Given this info dict::

    crime_detail_info = {
        "queryset" : Crime.objects.all(),
        "template_name" : "crimes/crime_detail.html",
        "template_object_name" : "crime",
    }

We could use a urlpattern like::

    (r'^/crimes/(?P<object_id>\d+)/$', 'object_detail', crime_detail_info),

to show details about a given crime, rendered in the
``crimes/crime_detail.html`` template. In that template, the ``Crime`` object
itself would be put into the ``{{ crime }}`` variable.

Required arguments
``````````````````

    `queryset``
        A ``QuerySet`` that will be searched for the object.

Either:


    ``object_id``
        The value of the primary-key field for the object.

or:

    ``slug``
        The slug of the given object.  If you pass this field, then
        the ``slug_field`` argument (below) is also required.


Optional arguments
``````````````````

    ``slug_field``
        The name of the field on the object containing the slug.  This is
        required if you are using the ``slug`` argument, but must be absent
        if you're using the ``object_id`` argument.

    ``template_name_field``
        The name of a field on the object whose value is the template name to
        use. This lets you store template names in your data.

        In other words, if your object has a field ``'the_template'`` that
        contains a string ``'foo.html'``, and you set ``template_name_field``
        to ``'the_template'``, then the generic view for this object will use
        the template ``'foo.html'``.

        It's a bit of a brain-bender, but it's useful in some cases.

    ``context_processors``

    ``extra_context``

    ``mimetype``

    ``template_loader``

    ``template_name``

    ``template_object_name``
        These arguments are as described above.

Template name
`````````````

If ``template_name`` and ``template_name_field`` aren'ti specified, this view
will use the template ``<app_label>/<model_name>_detail.html`` by default.

Template context
````````````````

In addition to ``extra_context``, the template's context will be:

    ``object``
        The object. This variable's name depends on the
        ``template_object_name`` parameter, which is ``'object'`` by default.
        If ``template_object_name`` is ``'foo'``, this variable's name will be
        ``foo``.

Date-based generic views
========================

Create/update/delete generic views
==================================

The ``django.views.generic.create_update`` module contains a set of functions
for creating, editing and deleting objects.

Creating object view
--------------------

The ``django.views.generic.create_update.create_object`` displays a form for
creating an object, redisplays the form with validation errors (if there are
any) and saves the object. This uses the automatic manipulators that come
with Django models.

Example
```````

XXX FIXME XXX

Required arguments
``````````````````

    ``model``
        The Django model of the object that the form will create.

Optional arguments
``````````````````

    ``post_save_redirect``
        A URL to which the view will redirect after saving the object. By
        default, it's ``object.get_absolute_url()``.

    ``post_save_redirect``
        may contain dictionary string formatting, which will be interpolated
        against the object's field attributes. For example, you could use
        ``post_save_redirect="/polls/%(slug)s/"``.

    ``login_required``
        A boolean that designates whether a user must be logged in, in order
        to see the page and save changes. This hooks into the Django
        authentication system. By default, this is ``False``.

         If this is ``True``, and a non-logged-in user attempts to visit this
        page or save the form, Django will redirect the request to
        ``/accounts/login/``.

    ``template_name``

    ``template_loader``

    ``extra_context``

    ``context_processors``
        These are the same as the views above.

Template name
`````````````

If ``template_name`` isn't specified, this view will use the template
``<app_label>/<model_name>_form.html`` by default.

Template context
````````````````

In addition to ``extra_context``, the template's context will be:

    ``form``:
        A ``FormWrapper`` instance representing the form for editing the
        object. This lets you refer to form fields easily in the template
        system.

         For example, if the model has two fields, ``name`` and ``address``::

              <form action="" method="post">
              <p><label for="id_name">Name:</label> {{ form.name }}</p>
              <p><label for="id_address">Address:</label> {{ form.address }}</p>
              </form>

          See Chapter 7 for more information about working with forms.

Update object view
------------------

This view is almost identical to the create-object view above, but this one
allows the editing of an existing object instead of the creation of a new one.

Example
```````

Required arguments
``````````````````

Optional arguments
``````````````````

Template name
`````````````

Template context
````````````````