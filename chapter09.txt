========================
Chapter 9: Generic views
========================

Here again is a recurring theme of this book: at its worst, Web development is
boring and monotonous.

So far, we've covered how Django tries to take away some of that monotony at
the model and template layers, but Web developers also experience this boredom
at the view level.

Django's **generic views** were developed to ease that pain. They take
certain common idioms and patterns found in view development and abstract them so that
you can quickly write common views of onto data without having to write too much
code. In fact, nearly every view example in the preceding chapters could be
re-written with the help of generic views.

Chapter 8 touched briefly on how you'd go about making a view "generic." To
review, we can recognize certain common tasks (like displaying a list of
objects) and write code that displays a list of *any* object. Then the model in
question can be passed as an extra argument to the URLconf.

Django ships with generic views to do the following:

    * Perform common "simple" tasks: redirect to a different page, and
      render a given template.

    * Display list and detail pages for a single object. The ``event_list`` and
      ``entry_list`` views from Chapter 8 are examples of list views; a single
      event page is an example of what we call a "detail" view.

    * Present date-based objects in year/month/day archive pages,
      associated detail, and "latest" pages.  The Django weblog's
      (http://www.djangoproject.com/weblog/) year, month, and
      day archives are built with these, as would be a typical
      newspaper's archives.

    * Allow users to create, update, and delete objects -- with or
      without authorization.

Taken together, these views provide easy interfaces to perform the most common
tasks developers encounter.

Using generic views
===================

All of these views are used by creating configuration dictionaries in
your URLconf files and passing those dictionaries as the third member of the
URLconf tuple for a given pattern.

For example, here's a simple URLconf you could use to present a static "about"
page::

    from django.conf.urls.defaults import *
    from django.views.generic.simple import direct_to_template

    urlpatterns = patterns('',
        ('^about/$', direct_to_template, {
            'template': 'about.html'
        })
    )

Though this might seem a bit "magic" at first glance -- look, a view with no
code! -- it's actually exactly the same as the examples in Chapter 8: the
``direct_to_template`` view simply grabs information from the extra-parameters
dictionary and uses that information when rendering the view.

Because this generic view -- and all the others -- are regular view functions
like any other, we can reuse them inside our own views. As an example, let's
extend our "about" example to map URLs of the form ``/about/<whatever>/`` to
statically rendered ``about/<whatever>.html``. We'll do this by first modifying
the URLconf to point to a view function:

.. parsed-literal::

    from django.conf.urls.defaults import *
    from django.views.generic.simple import direct_to_template
    **from bookstore.views import about_pages**

    urlpatterns = patterns('',
        ('^about/$', direct_to_template, {
            'template': 'about.html'
        }),
        **('^about/(\w+)/$', about_pages),**
    )

Next, we'll write the ``about_pages`` view::

    from django.http import Http404
    from django.template import TemplateDoesNotExist
    from django.views.generic.simple import direct_to_template

    def about_pages(request, page):
        try:
            return direct_to_template(request, template="about/%s.html" % page)
        except TemplateDoesNotExist:
            raise Http404()

Here we're treating ``direct_to_template`` like any other function. Since it
returns an ``HttpResponse``, we can simply return it as-is. The only slightly
tricky business here is dealing with missing templates: we don't want a
non-existent template to cause a server error, so we catch
``TemplateDoesNotExist`` exceptions and return 404 errors instead.

.. admonition:: Is there a security vulnerability here?

    Sharp-eyed readers may have noticed a possible security hole: we're
    constructing the template name using interpolated content from the browser
    (``template="about/%s.html" % page``). At first glance, this looks like a
    classic *directory traversal* vulnerability (discussed in detail in Chapter
    19). But is it really?

    Not exactly. Yes, a maliciously crafted value of ``page`` could cause
    directory traversal, but although ``page`` *is* taken from the request URL,
    not every value will be accepted. They key is in the URLconf: we're using
    the regular expression ``\w+`` to match the ``page`` part of the URL, and
    ``\w`` only accepts letters and numbers. Thus, any malicious characters
    (dots and slashes, here) will be rejected by the URL resolver before they
    reach the view itself.

Generic views of objects
========================

The ``direct_to_template`` certainly is useful, but Django's generic views
really shine when it comes to presenting views on your database content. Because
it's such a common task, Django comes with a handful of built-in generic views
that make generating list and detail views of objects incredibly easy.

Let's take a look at one of these generic views: the "object list" view. We'll
be using this ``Book`` object from Chapter 5::

    class Book(models.Model):
        title = models.CharField(maxlength=100)
        authors = models.ManyToManyField(Author)
        publisher = models.ForeignKey(Publisher)
        publication_date = models.DateField()

To build a list page of all books, we'd use a URLconf along these lines::

    from django.conf.urls.defaults import *
    from django.views.generic import list_detail
    from bookstore.models import Book

    book_info = {
        "queryset" : Book.objects.all(),
    }

    urlpatterns = patterns('',
        (r'books/$', list_detail.object_list, book_info)
    )

That's all the Python code we need to write. We'll still need to write a
template, however. We could explicitly tell the ``object_list`` view which
template to use by including a ``template_name`` key in the extra arguments
dictionary, but in the absence of an explicit template Django will infer one
from the object's name. In this case, the inferred template will be
``"bookstore/book_list.html"`` -- the "bookstore" part comes from the name of
the app that defines the model; the "book" bit is just the lowercased version of
the model's name.

This template will be rendered against a context containing a variable called
``object_list`` which contains all the book objects. A very simple template
might look like::

    {% extends "base.html" %}

    {% block content %}
        <h2>Books</h2>
        <ul>
            {% for book in object_list %}
                <li>{{ book.title }}</li>
            {% endfor %}
        </ul>
    {% endblock %}

That's really all there is to it. All the cool features of generic views come
from changing the "info" dictionary passed to the generic view. Appendix D
documents all the generic views and all their options in detail; the rest of
this chapter will consider some of the common ways you might customize and
extend generic views.

Extending generic views
=======================

There's no question that using generic views can speed up development
substantially. In most projects, however, there comes a moment when the
generic views no longer suffice. Indeed, the most common question asked by new
Django developers is about how to make generic views handle a wider array of
situations.

Luckily, in nearly every one of these cases, there are ways to simply extend
generic views to handle a larger array of use cases. These situations usually
fall into a handful of patterns dealt with below.

Making "friendly" template contexts
-----------------------------------

You might have noticed that sample book list template above stores all the books
in a variable named ``object_list``. While this works just fine, it isn't all
that "friendly" to template authors: they have to "just know" that they're
dealing with books here. A better name for that variable would be ``book_list``;
that variable's content is pretty obvious.

We can do that easily with the ``template_object_name`` argument:

.. parsed-literal::

    book_info = {
        "queryset" : Book.objects.all(),
        "template_object_name" : "book",
    }

    urlpatterns = patterns('',
        (r'books/$', list_detail.object_list, book_info)
    )

Providing a useful ``template_object_name`` is always a good idea; your coworkers
who design templates will thank you.

Adding extra context
--------------------

Often you simply need to present some extra information than that provided by
the generic view. For example, think of showing a list of all publishers on a
book's detail page; the ``object_detail`` generic view provides the book to the
context, but it seems there's no way to get a list of publishers in that
template.

But there is: all generic views take an extra optional parameter
``extra_context``. This is a dictionary of extra objects which will be added to
the template's context. So, to provide the list of publishers in the book detail
view, we'd use an info dict like this:

.. parsed-literal::

    book_info = {
        "queryset" : Book.objects.all(),
        **"extra_context" : {"publisher_list" : Publisher.objects.all()}**
    }

This would populate a ``{{ publisher_list }}`` variable in the template context.
This pattern can be used to pass any information down into the template for the
generic view. It's very handy.

However, there's actually a subtle bug here -- can you spot it?

The problem has to do with when the queries in ``extra_context`` are evaluated.
Because this example puts ``Publisher.objects.all()`` in the URLconf, it will
only be evaluated once (when the URLconf is first loaded). Once you add or
remove publishers you'll notice that the generic view doesn't reflect those
changes until you reload the Web server (see "Caching and QuerySets" in Appendix
C for more information about when QuerySets are cached and evaluated).

The solution is to use a callback in ``extra_context`` instead of a value. Any
callable (i.e. a function) that's passed to ``extra_context`` will be evaluated
when the view is rendered (instead of only once). You could do this with an
explicitly defined function:

.. parsed-literal::

    def get_publishers():
        return Publisher.objects.all()

    book_info = {
        "queryset" : Book.objects.all(),
        "extra_context" : **{"publisher_list" : get_publishers}**
    }

or you could use a less-obvious but shorter version that relies on the fact that
``Publisher.objects.all`` is itself a callable:

.. parsed-literal::

    book_info = {
        "queryset" : Book.objects.all(),
        "extra_context" : **{"publisher_list" : Publisher.objects.all}**
    }

Notice the lack of parentheses after ``Publisher.objects.all``; this references
the function without actually calling it (which the generic view will do later).

Viewing subsets of objects
--------------------------

Now let's take a closer look at this ``queryset`` key we've been using all
along. Most generic views take one of these ``queryset`` arguments; it's how the
view knows which set of objects to display (see "Selecting objects" in Chapter 5
for an introduction to QuerySets, and see Appendix C for the complete details).

To pick a simple example, we might want to order the list of books by
publication date, most recent first:

.. parsed-literal::

    book_info = {
        "queryset" : Book.objects.all()**.order_by("-publication_date")**,
    }


That's a pretty simple example, but it illustrates the idea nicely. Of course,
you'll usually want to do more than just reorder objects. If you wanted to
present a list of books by a particular publisher, you could use the same
technique:

.. parsed-literal::

    **apress_books = {**
        **"queryset": Book.objects.filter(publisher__name="Apress"),**
        **"template_name" : "bookstore/apress_list.html"**
    **}**

    urlpatterns = patterns('',
        (r'books/$', list_detail.object_list, book_info),
        **(r'books/apress/$', list_detail.object_list, apress_books),**
    )

Notice that along with a filtered ``queryset`` we're also using a custom
template name. If we didn't it would use the same template as the "vanilla"
object list, which might not be what we want.

Also notice that this isn't a very elegant way of doing publisher-specific
books: if we want to add another publisher page, we'd need another handful of
lines in the URLconf, and more than a few publishers would get unreasonable.
We'll deal with this problem in the next section.

Complex filtering with wrapper functions
----------------------------------------

Another common need is to filter down the objects given in a list page by some
key in the URL. Above we hardcoded the publisher's name in the URLconf, but what
if we wanted to write a view that displayed all the books by some arbitrary
publisher? We can "wrap" the ``object_list`` generic view to avoid writing a lot
of code by hand. As usual, we'll start by writing a URLconf:

.. parsed-literal::

    urlpatterns = patterns('',
        (r'books/$', list_detail.object_list, book_info),
        **(r'books/(\w+)/$', books_by_publisher),**
    )

Next, we'll write the ``books_by_publisher`` view itself::

    from django.http import Http404
    from django.views.generic import list_detail
    from bookstore.models import Author, Publisher

    def books_by_publisher(request, name):

        # Look up the publisher (and return a 404 if it can't be found).
        try:
            publisher = Publisher.objects.get(name__iexact=name)
        except Publisher.DoesNotExist:
            raise Http404

        # Use the object_list view for the heavy lifting.
        return list_detail.object_list(
            request,
            queryset = Book.objects.filter(publisher=publisher),
            template_name = "bookstore/books_by_publisher.html",
            template_object_name = "books",
            extra_context = {"publisher" : publisher}
        )

This works because there's really nothing special about generic views --
they're just Python functions. Like any view function, generic views expect a
certain set of arguments and return ``HttpResponse`` objects. Thus, it's
incredibly easy to wrap a small function around a generic view that does
additional work before (or after; see below) handing things off to the
generic view.

.. note::

    Notice that in the above example we've passed the current publisher being
    displayed in the ``extra_context``. This is usually a good idea in wrappers
    of this nature; it lets the template know which "parent" object is currently
    being browsed.

Performing extra work
---------------------

The last common pattern we'll look at involves doing some extra work before
or after calling the generic view.

Imagine we had a ``last_accessed`` field on our ``Author`` object that we were
using to keep track of the last time a anybody looked at that author.  The generic
``object_detail`` view, of course, wouldn't know anything about this field, but
once again we could easily write a custom view to keep that field updated.

First, we'd need to modify the author detail bit in the URLconf to point to a
custom view:

.. parsed-literal::

    from bookstore.views import author_detail

    urlpatterns = patterns('',
        #...
        **(r'^authors/(?P<author_id>\d+)/$', author_detail),**
    )

Then we'd write our wrapper function::

    import datetime
    from bookstore.models import Author
    from django.views.generic import list_detail
    from django.shortcuts import get_object_or_404

    def author_detail(request, author_id):
        # Look up the Author (and raise a 404 if she's not found)
        author = get_object_or_404(Author, pk=author_id)

        # Record the last accessed date
        author.last_accessed = datetime.datetime.now()
        author.save()

        # Show the detail page
        return list_detail.object_detail(
            request,
            queryset = Author.objects.all(),
            object_id = author_id,
        )

.. note::

    This code won't actually work unless you add a ``last_accessed`` field
    to your ``Author`` model.

We can use a similar idiom to alter the response returned by the generic view.
If we wanted to provide a downloadable plain-text version of the list of authors,
we could use a view like this::

    def author_list_plaintext(request):
        response = list_detail.object_list(
            queryset = Author.objects.all(),
            mimetype = "text/plain",
            template_name = "bookstore/author_list.txt"
        )
        response["Content-Disposition"] = "attachment; filename=authors.txt"
        return response

This works because the generic views return simple ``HttpResponse`` objects
which can be treated like dictionaries to set HTTP headers. This
``Content-Disposition`` business, by the way, instructs the browser to
download and save the page instead of displaying it in the browser.

What's next?
============

We've only looked at a couple of the generic views Django ships with, but the
general ideas presented in this chapter should apply pretty closely to any
generic view. Appendix D covers all the available views in detail; it's
recommended reading if you want to get the most out of this powerful feature.

In the next chapter we'll delve deep into the inner workings of Django's
templates, showing all the cool ways it can be extended. Until now, we've
treated the template engine as a mostly static tool you can use to render your
content.