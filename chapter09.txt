========================
Chapter 9: Generic views
========================

Here again is a recurring theme of this book: at its worst, web development is
boring and monotonous.

So far we've covered how Django tries to take away some of that monotony at
the model and template layers, but web developers also experience this boredom
at the view level.

Django's **generic views** were to developed to ease that pain. They take
certain common idioms and patterns in view development and abstract them so that
you can quickly write common views of onto data without having to write too much
code. In fact, nearly every view example in the preceding chapters could be
re-written with the help of generic views.

Chapter 8 touched briefly on how you'd go about making a view "generic." To
review, we can recognize certain common tasks (like displaying a list of
objects) and write code that displays a list of *any* object. Then the model in
question can be passed as an extra argument to the URLconf.

Django ships with generic views to do the following:

    * Perform common "simple" tasks: redirect to a different page, and
      render a given template.

    * Display list and detail pages for a single object. The ``event_list`` and
      ``entry_list`` views from Chapter 8 are examples of list views; a single
      event page is an example of what we call a "detail" view.
      
    * Present date-based objects in year/month/day archive pages,
      associated detail, and "latest" pages.  The Django weblog's
      (http://www.djangoproject.com/weblog/) year, month, and
      day archives are built with these, as would be a typical
      newspaper's archives.

    * Allow users to create, update, and delete objects -- with or
      without authorization.

Taken together, these views provide easy interfaces to perform the most common
tasks developers encounter.

Using generic views
===================

All of these views are used by creating configuration dictionaries in
your URLconf files and passing those dictionaries as the third member of the
URLconf tuple for a given pattern.



For example, here's the URLconf for the simple weblog app that drives the blog
on djangoproject.com::

    from django.conf.urls.defaults import *
    from django_website.apps.blog.models import Entry

    info_dict = {
        'queryset': Entry.objects.all(),
        'date_field': 'pub_date',
    }

    urlpatterns = patterns('django.views.generic.date_based',
       (r'^(?P<year>\d{4})/(?P<month>[a-z]{3})/(?P<day>\w{1,2})/(?P<slug>[-\w]+)/$', 'object_detail', dict(info_dict, slug_field='slug')),
       (r'^(?P<year>\d{4})/(?P<month>[a-z]{3})/(?P<day>\w{1,2})/$',                  'archive_day',   info_dict),
       (r'^(?P<year>\d{4})/(?P<month>[a-z]{3})/$',                                   'archive_month', info_dict),
       (r'^(?P<year>\d{4})/$',                                                       'archive_year',  info_dict),
       (r'^/?$',                                                                     'archive_index', info_dict),
    )

As you can see, this URLconf defines a few options in ``info_dict``.
``'queryset'`` gives the generic view a ``QuerySet`` of objects to use (in
this case, all of the ``Entry`` objects) and tells the generic view which
model is being used.  The remaining arguments to each generic view are taken
from the named captures in the URLconf.

This is really all the "view" code for Django's weblog!  The only thing that's left
is writing a template.

Documentation of each generic view follows, along with a list of all keyword
arguments that a generic view expects. Remember that as in the example above,
arguments may either come from the URL pattern (as ``month``, ``day``,
``year``, etc. do above) or from the additional-information dictionary (as for
``queryset``, ``date_field``, etc.).

Most generic views require the ``queryset`` key, which is a ``QuerySet``
instance; see the database API reference in Appendix C for more information
about ``QuerySet`` objects.

Most views also take an optional ``extra_context`` dictionary that you can use
to pass any auxiliary information you wish to the view. The values in the
``extra_context`` dictionary can be either functions (or other callables) or
other objects. Functions are evaluated just before they are passed to the
template.

More complex generic views
==========================

Although the simple generic views certainly are useful, the real power in
Django's generic views comes from the more complex views that allow you to
build common CRUD (Create/Retrieve/Update/Delete) pages with a minimum amount
of code.

These views break down into a few different types:

    * List/detail views, which provide flat lists of objects and individual
      object detail pages (for example, a list of places and individual
      place information pages).
      
    * Date-based views, which provide year/month/day drill-down pages of
      date-centric information.
      
    * Create/update/delete views, which allow you to quickly create views
      to create, modify, or delete objects.

Extending generic views
=======================

There's no question that using generic views can speed up development
substantially. In most projects, however, there comes a moment when the
generic views no longer suffice. Indeed, the most common question asked by new
Django developers is about how to make generic views handle a wider array of
situations.

Luckily, in nearly every one of these cases, there are ways to simply extend
generic views to handle a larger array of use cases. These situations usually
fall into a couple of patterns:

Adding extra context
--------------------

Often you simply need to present some extra information than that provided by
the generic view. For example, think of showing a list of all publishers on a
book's detail page; the ``object_detail`` generic view provides the book to
the context, but it seems there's no way to get a list of publishers in that
template.

But there is: all generic views take an extra optional parameter
``extra_context``. This is a dictionary of extra objects which will be added
to the template's context.  So, to provide the list of publishers in the
book detail view, we'd use an info dict like this::
    
    book_info = {
        "queryset"   : Book.objects.all(),
        "date_field" : "publication_date",
        "extra_context" : {
            "publisher_list" : Publisher.objects.all(),
        }
    }
    
This would populate a ``{{ publisher_list }}`` variable in the template
context. This pattern can be used to pass any information down into the
template for the generic view; it's very handy.

More complex filtering with wrapper functions
---------------------------------------------

Another common need is to filter down the objects given in a list page by some
key in the URL. For example, let's look at providing an interface to browse
books by title. We'd like to provide URLs of the form ``/books/by-title/a/``,
``/books/by-title/b/``, etc. -- one list page for each letter of the alphabet.

The problem seems to be that the generic view has no concept of reading
variables from the URL; if we wired a URL pattern matching those URLs up to
the ``object_list`` view, we'd get twenty-six pages displaying all the books.
Although we *could* write twenty-six different info dicts (each with a
different ``queryset`` argument), that's just silly. The right technique
involves writing a simple "wrapper" function around the generic view.

In our alphabetic-browsing example, we'd start by adding a small bit to the
URLconf:

.. parsed-literal::
 
    from bookstore.views import browse_alphabetically

    urlpatterns = patterns('', 
        # ...
        **(r'^books/by-title/([a-z])/$', browse_alphabetically)**
    )

As you can see, this wires the set of URLs to the ``browse_alphabetically``
function, so let's take a look at how that function could be written::

    from bookstore.models. import Book
    from django.views.generic import list_detail
    
    def browse_alphabetically(request, letter):
        return list_detail.object_list(
            request,
            queryset = Book.objects.filter(title__istartswith=letter),
            template_name = "bookstore/browse_alphabetically.html",
            extra_context = {
                'letter' : letter,
            }
        )

That's it!

This works because there's really nothing special about generic views --
they're just Python functions. Like any view function, generic views expect a
certain set of arguments and return ``HttpResponse`` objects. Thus, it's
incredibly easy to wrap a small function around a generic view that does
additional work before -- or after; see below -- handing things off to the
generic view.

.. note::

    Notice that in the above example we've passed the current letter being
    display in the ``extra_context``. This is usually a good idea in wrappers
    of this nature; it lets the template know which letter is currently being
    browsed.
    
    Also (while we're on the topic of templates) notice that we've passed in
    a custom template name. Without that, it would try to use the same
    template as a "vanilla" ``object_list``, which could conflict with other
    generic views.


Performing extra work
---------------------

The last common pattern we'll look at involves doing some extra work before
or after calling the generic view.

Imagine we had a ``last_accessed`` field on our ``Author`` object that we were
using to keep track of the last time a anybody looked at that author.  The generic
``object_detail`` view, of course, wouldn't know anything about this field, but
once again we could easily write a custom view to keep that field updated.

First, we'd need to modify the author detail bit in the URLconf to point to a
custom view:

.. parsed-literal::

    from bookstore.views import author_detail
    
    urlpatterns = patterns('',
        #...
        **(r'^authors/(?P<author_id>\d+)/$', author_detail),**
    )

Then we'd write our wrapper function::

    import datetime
    from bookstore.models import Author
    from django.views.generic import list_detail
    from django.shortcuts import get_object_or_404

    def author_detail(request, author_id):
        # Look up the Author (and raise a 404 if she's not found)
        author = get_object_or_404(Author, pk=author_id)
        
        # Record the last accessed date
        author.last_accessed = datetime.datetime.now()
        author.save()
        
        # Show the detail page
        return list_detail.object_detail(
            request,
            queryset = Author.objects.all(),
            object_id = author_id,
        )

.. note::

    This code won't actually work unless you add the ``last_accessed`` field
    to your ``Author`` model.
    
We can use a similar idiom to alter the response returned by the generic view.
If we wanted to provide a downloadable plain-text version of the list of authors,
we could use a view like this::

    def author_list_plaintext(request):
        response = list_detail.object_list(
            queryset = Author.objects.all(),
            mimetype = "text/plain",
            template_name = "bookstore/author_list.txt"
        )
        response["Content-Disposition"] = "attachment; filename=authors.txt"
        return response
        
This works because the generic views return simple ``HttpResponse`` objects
which can be treated like dictionaries to set HTTP headers. This
``Content-Disposition`` business, by the way, instructs the browser to
download and save the page instead of displaying it in the browser.

What's next?
============

Until now, we've treated the template engine as a mostly static tool you can
use to render your content. It's true that most of the time you'll just treat
it in that way, but the template engine is actually quite extensible.

In the next chapter we'll delve deep into the inner workings of Django's
templates, showing all the cool ways it can be extended.

Onward, comrades!