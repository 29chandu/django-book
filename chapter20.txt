========
Security
========

The internet can be a scary place.

In the past few years, internet horror stories have been in the news almost
continuously. We've seen viruses spread with amazing speed, swarms of
compromised computers wielded as weapons, a never-ending arms race against
spammers, and many, many reports of identify theft from compromised web sites.

As good web developers, it's our duty to do what we can to combat these forces
of darkness. Every web developer needs to treat security as a fundamental
aspect of web programming. Unfortunately, it turns out that security is *hard*
-- attackers only need to find a single vulnerability, but defenders have to
protect every single one.

Django attempts to mitigate this difficulty; it's designed to automatically
protect you from many of the common security mistakes that new (and even
experienced) web developers make. Still, it's important to understand what
these problems are, how Django protects you, and -- most importantly -- the
steps you can take to make your code even more secure.

First, though, an important disclaimer: we're in no way experts in this realm,
and so we won't try to explain each vulnerability in a comprehensive manner.
Instead, we'll give a short synopsis of security problems as they apply to
Django. For those interested in a more in-depth discussion of web security, we
recommend XXX.

The theme of web security
=========================

If you learn only one thing from this chapter, let it be this:

    Never -- under any circumstances -- trust data from the browser.
    
You *never* know who's on the other side of that HTTP connection. It might be
one of your users, but it just as easily could be a cracker or script kiddie
looking for an opening.

Any data of any nature that comes from the browser needs to be treated with a
healthy dose of paranoia. This includes data that's both "in band" -- i.e.
submitted from web forms -- and "out of band" -- i.e. HTTP headers, cookies,
and other request info. It's trivial to spoof the request metadata that
browsers usually add automatically.

Every one of the vulnerabilities discussed in this chapter stems directly from
trusting data that comes over the wire and then failing to sanitize that data
before using it. You should make it a general practice to continuously ask,
"where does this data come from?".

SQL injection
=============

**SQL injection** is a common exploit in which an attacker alters Web-page
parameters (such as GET/POST data or URLs) to insert arbitrary SQL snippets
that a naive Web application executes in its database directly.

This vulnerability most commonly crops up when constructing SQL "by hand" from
user input. For example, imagine writing a function to gather a list of a
contact info from a contact search page. To prevent spammers from reading
every single email in our system, we'll force the user to type in someone's
username before we provide their email address::

    def user_contacts(request):
        user = request.GET['username']
        sql = "SELECT * FROM user_contacts WHERE username = '%s';" % username
        # execute the SQL here...
        
.. note::

    In this example, and all similar "don't do this" examples that follow,
    we've deliberately left out most of the code needed to make the functions
    actually work. We don't want this code to work if someone accidentally
    takes it out of context.
    
Though at first this doesn't look dangerous, it's really is. First, our
attempt at protecting our entire email list will fail with a cleverly
constructed query.

Think about what happens if an attacker types ``"' OR 'a'='a"`` into the query
box. In that case, the query that the string interpolation will construct will
be::

    SELECT * FROM user_contacts WHERE username = '' OR 'a' = 'a';
    
Because we allowed unsecured SQL into the string, the attacker's added ``OR``
clause ensures that every single row is returned.

However, that's the *least* scary attack. Imagine what will happen if the
attacker submits ``"'; DELETE FROM user_contacts WHERE 'a' = 'a``". We'll end
up with this complete query::

    SELECT * FROM user_contacts WHERE username = ''; DELETE FROM user_contacts WHERE 'a' = 'a';
    
Yikes! Where'd our contact list go?

The solution
------------

Although this problem is insidious and sometimes hard to spot, the solution is
simple: *never* trust user-submitted data, and *always* escape it when passing
it into SQL.

The Django database API does this for you. It automatically escapes all
special SQL parameters, according to the quoting conventions of the database
server you're using (e.g. PostgreSQL, MySQL).

For example, in this API call::

    foo.get_list(bar__exact="' OR 1=1")

Django will escape the input accordingly, resulting in a statement like this::

    SELECT * FROM foos WHERE bar = '\' OR 1=1'
    
Which is harmless.

This applies to the entire Django database API, with a couple of exceptions:

    * The ``where`` argument to the ``extra()`` method (see Appendix XXX).
      That parameter accepts raw SQL by design.

    * Queries done "by hand" using the lower-level database API.

In each of these cases, it's easy to keep yourself protected. In each case,
avoid string interpolation in favor of passing in "bind parameters". That is,
the example we started this section with should be written::

    from django.db import connection

    def user_contacts(request):
        user = request.GET['username']
        sql = "SELECT * FROM user_contacts WHERE username = %s"
        cursor = connection.cursor()
        cursor.execute(sql, [user])
        # ... do something with the results
        
The low-level ``execute`` method takes a SQL string with ``%s`` placeholders,
and automatically escapes and inserts parameters from the list passed as the
second argument. You should *always* construct custom SQL this way.

E-mail header injection
=======================

SQL injections less-well-known sibling, **e-mail header injection** hijacks
email-sending web forms and uses them to send spam. Any form that constructs
email headers from web form data is a target for this kind of attack.

Let's look at the canonical contact form found on many sites. Usually this
emails a hard-coded email address, and so at first glance doesn't appear
vulnerable to spam abuse.

However, most of these forms also allow the user to type in his own subject
for the email (along with a from address, body, and sometimes a few other
fields). This subject field is used to construct the "subject" header of the
email message.

If that header is unescaped when building the email message, an attacker could
use something like ``"hello\ncc:spamvictim@example.com"`` (where ``"\n``" is a
newline character). That would make the constructed email headers turn into::

    To: hardcoded@example.com
    Subject: hello
    cc: spamvictim@example.com
    
Like SQL injection, if we trust the subject line given by the user, we'll
allow him to construct a malicious set of headers, and they can use our
contact form to send spam.

The solution
------------

We can prevent this attack in the same way we prevent SQL injection: always
escape or validate user-submitted content.

Django's built-in mail functions (in ``django.core.mail``) simply do not allow
newlines in any fields used to construct headers (the from and to addresses
and the subject). If you try to use ``django.core.mail.send_mail`` with a
subject that contains newlines, Django will raise a ``BadHeaderError``
exception.

If you decide to use other methods of sending email, you'll need to make sure that newlines in headers either cause an error or are stripped. You may want to examine the ``SafeMIMEText`` class in ``django.core.mail`` to see how Django does this.

Exposed error messages
======================

The problem
-----------

Django's philosophy is that site visitors should never see application-related
error messages. If your code raises an unhandled exception, a site visitor
should not see the full traceback -- or *any* hint of code snippets or Python
(programmer-oriented) error messages. Instead, the visitor should see a
friendly "This page is unavailable" message.

Any code errors and tracebacks displayed to the public could give valuable
insight to a malicious hacker.

Naturally, of course, developers need to see tracebacks to debug problems in
their code. So the framework should hide all error messages from the public,
but it should display them to the trusted site developers.

The solution
------------

Cross-site Scripting (XSS)
==========================

More
================

[3:19pm] adrian_h: Hmm..
[3:20pm] jacobkm: probably something about man-in-the-middle session attacks (which can only really be stopped by using https)
[3:20pm] adrian_h: Session stuff -- essentially an explanation of how sessions are tied to a session cookie and it's relying solely on unguessability of the session ID
[3:20pm] jacobkm: Yeah
[3:21pm] adrian_h: There's really no way around that unless you also key it on IP address or user agent, but there are problems with those approaches -- maybe it could discuss that
[3:21pm] jacobkm: yup
[3:22pm] jacobkm: I think I'm more or less gonna say that if you want to be really protected from that stuff that you'll need to use ssl
[3:22pm] adrian_h: One thing we do as an extra security precaution is reset the session key if an attempt is made to guess it -- see line 60 in contrib/sessions/middleware.py
[3:22pm] jacobkm: right, yeah
[3:22pm] jacobkm: that's smart :)
[3:23pm] adrian_h: http://en.wikipedia.org/wiki/Category:Web_security_exploits
[3:23pm] jacobkm: Ooh, that's a good place to start
[3:23pm] adrian_h: There are a couple of links on this ticket, too -- http://code.djangoproject.com/ticket/362
[3:24pm] jacobkm: oh, X-Forwarded-For needs a mention, too
[3:24pm] adrian_h: Also, our session framework intentionally doesn't allow for session IDs to be passed in URLs, because that's an exploit waiting to happen
[3:24pm] jacobkm: Right
[3:24pm] adrian_h: This is going to be a fun chapter!
[3:24pm] jacobkm: I think I mentioned that in the sessions chapter.
[3:24pm] jacobkm: Heh
[3:25pm] adrian_h: We already have a section about the CSRF middleware (in the contrib chapter), but you could just mention that again, with a pointer to that chapter
[3:25pm] jacobkm: right