========
Security
========

.. contents:: 

The internet can be a scary place.

In the past few years, internet horror stories have been in the news almost
continuously. We've seen viruses spread with amazing speed, swarms of
compromised computers wielded as weapons, a never-ending arms race against
spammers, and many, many reports of identify theft from compromised web sites.

As good web developers, it's our duty to do what we can to combat these forces
of darkness. Every web developer needs to treat security as a fundamental
aspect of web programming. Unfortunately, it turns out that security is *hard*
-- attackers only need to find a single vulnerability, but defenders have to
protect every single one.

Django attempts to mitigate this difficulty; it's designed to automatically
protect you from many of the common security mistakes that new (and even
experienced) web developers make. Still, it's important to understand what
these problems are, how Django protects you, and -- most importantly -- the
steps you can take to make your code even more secure.

First, though, an important disclaimer: we're in no way experts in this realm,
and so we won't try to explain each vulnerability in a comprehensive manner.
Instead, we'll give a short synopsis of security problems as they apply to
Django. For those interested in a more in-depth discussion of web security, we
recommend XXX.

The theme of web security
=========================

If you learn only one thing from this chapter, let it be this:

    Never -- under any circumstances -- trust data from the browser.
    
You *never* know who's on the other side of that HTTP connection. It might be
one of your users, but it just as easily could be a cracker or script kiddie
looking for an opening.

Any data of any nature that comes from the browser needs to be treated with a
healthy dose of paranoia. This includes data that's both "in band" -- i.e.
submitted from web forms -- and "out of band" -- i.e. HTTP headers, cookies,
and other request info. It's trivial to spoof the request metadata that
browsers usually add automatically.

Every one of the vulnerabilities discussed in this chapter stems directly from
trusting data that comes over the wire and then failing to sanitize that data
before using it. You should make it a general practice to continuously ask,
"where does this data come from?".

SQL injection
=============

**SQL injection** is a common exploit in which an attacker alters Web-page
parameters (such as GET/POST data or URLs) to insert arbitrary SQL snippets
that a naive Web application executes in its database directly.

This vulnerability most commonly crops up when constructing SQL "by hand" from
user input. For example, imagine writing a function to gather a list of a
contact info from a contact search page. To prevent spammers from reading
every single email in our system, we'll force the user to type in someone's
username before we provide their email address::

    def user_contacts(request):
        user = request.GET['username']
        sql = "SELECT * FROM user_contacts WHERE username = '%s';" % username
        # execute the SQL here...
        
.. note::

    In this example, and all similar "don't do this" examples that follow,
    we've deliberately left out most of the code needed to make the functions
    actually work. We don't want this code to work if someone accidentally
    takes it out of context.
    
Though at first this doesn't look dangerous, it's really is. First, our
attempt at protecting our entire email list will fail with a cleverly
constructed query.

Think about what happens if an attacker types ``"' OR 'a'='a"`` into the query
box. In that case, the query that the string interpolation will construct will
be::

    SELECT * FROM user_contacts WHERE username = '' OR 'a' = 'a';
    
Because we allowed unsecured SQL into the string, the attacker's added ``OR``
clause ensures that every single row is returned.

However, that's the *least* scary attack. Imagine what will happen if the
attacker submits ``"'; DELETE FROM user_contacts WHERE 'a' = 'a``". We'll end
up with this complete query::

    SELECT * FROM user_contacts WHERE username = ''; DELETE FROM user_contacts WHERE 'a' = 'a';
    
Yikes! Where'd our contact list go?

The solution
------------

Although this problem is insidious and sometimes hard to spot, the solution is
simple: *never* trust user-submitted data, and *always* escape it when passing
it into SQL.

The Django database API does this for you. It automatically escapes all
special SQL parameters, according to the quoting conventions of the database
server you're using (e.g. PostgreSQL, MySQL).

For example, in this API call::

    foo.get_list(bar__exact="' OR 1=1")

Django will escape the input accordingly, resulting in a statement like this::

    SELECT * FROM foos WHERE bar = '\' OR 1=1'
    
Which is harmless.

This applies to the entire Django database API, with a couple of exceptions:

    * The ``where`` argument to the ``extra()`` method (see Appendix XXX).
      That parameter accepts raw SQL by design.

    * Queries done "by hand" using the lower-level database API.

In each of these cases, it's easy to keep yourself protected. In each case,
avoid string interpolation in favor of passing in "bind parameters". That is,
the example we started this section with should be written::

    from django.db import connection

    def user_contacts(request):
        user = request.GET['username']
        sql = "SELECT * FROM user_contacts WHERE username = %s;"
        cursor = connection.cursor()
        cursor.execute(sql, [user])
        # ... do something with the results
        
The low-level ``execute`` method takes a SQL string with ``%s`` placeholders,
and automatically escapes and inserts parameters from the list passed as the
second argument. You should *always* construct custom SQL this way.

Cross-site Scripting (XSS)
==========================

Start here: http://en.wikipedia.org/wiki/Cross-site_scripting

Cross-site Request Forgery (CSRF)
=================================

Refer to ch15.

Session forging/hijacking
=========================

i.e. don't trust the session cookie too much.

E-mail header injection
=======================

SQL injections less-well-known sibling, **e-mail header injection** hijacks
email-sending web forms and uses them to send spam. Any form that constructs
email headers from web form data is a target for this kind of attack.

Let's look at the canonical contact form found on many sites. Usually this
emails a hard-coded email address, and so at first glance doesn't appear
vulnerable to spam abuse.

However, most of these forms also allow the user to type in his own subject
for the email (along with a from address, body, and sometimes a few other
fields). This subject field is used to construct the "subject" header of the
email message.

If that header is unescaped when building the email message, an attacker could
use something like ``"hello\ncc:spamvictim@example.com"`` (where ``"\n``" is a
newline character). That would make the constructed email headers turn into::

    To: hardcoded@example.com
    Subject: hello
    cc: spamvictim@example.com
    
Like SQL injection, if we trust the subject line given by the user, we'll
allow him to construct a malicious set of headers, and they can use our
contact form to send spam.

The solution
------------

We can prevent this attack in the same way we prevent SQL injection: always
escape or validate user-submitted content.

Django's built-in mail functions (in ``django.core.mail``) simply do not allow
newlines in any fields used to construct headers (the from and to addresses
and the subject). If you try to use ``django.core.mail.send_mail`` with a
subject that contains newlines, Django will raise a ``BadHeaderError``
exception.

If you decide to use other methods of sending email, you'll need to make sure
that newlines in headers either cause an error or are stripped. You may want
to examine the ``SafeMIMEText`` class in ``django.core.mail`` to see how
Django does this.

Directory traversal
===================

**Directory traversal** is another injection-style attack wherein a malicious
user tricks filesystem code into reading and/or writing files that the web
server shouldn't have access to.

An example might be a view that reads files from the disk without carefully
sanitizing the file name::

    def dump_file(request):
        filename = request.GET["filename"]
        filename = os.path.join(BASE_PATH, filename)
        content = open(filename).read()
        
        # ...
        
Thought it looks like that view restricts file access to files beneath
``BASE_PATH`` (by using ``os.path.join``), if the attacker passes in a
``filename`` containing ``".."``, he can access files "above" ``BASE_PATH``.
It's only a matter of time before he can discover the correct number of
``".."``s to successfully access, say, ``../../../../../etc/passwd``.

Anything that reads files without proper escaping is vulnerable to this
problem. Views that *write* files are just as vulnerable, but the consequences
are doubly dire.

Another permutation of this problem lies in code that dynamically loads
modules based on the URL or other request information. A well-publicized
example came from the world of Ruby on Rails: Rails can map URLs like
``http://example.com/person/1`` directly to objects (without using any sort of
URLconf analog), and in mid-2006 it was discovered that carefully constructed
URLs could automatically load arbitrary code. In particular, the module that
caused a database reset could be loaded dynamically, and thus an attacker
could clear out your entire database!

.. JKM: I couldn't resist the jab at Rails. Is this OK or does it come across 
.. JKM: as mean-spirited?

The solution
------------

If your code ever needs to read or write files based on user input, you need
to very carefully sanitize the requested path to ensure that an attacker isn't
able to escape from the base directory you're restricting access to.

.. note::

    Needless to say, you should **never** write code that can read from any
    area of the disk!
    
A good example of how to do this escaping lies in the Django's built-in static
content serving view (in ``django.views.static``). Here's the relevant code::

    import os
    import posixpath
    
    # ...

    path = posixpath.normpath(urllib.unquote(path))
    newpath = ''
    for part in path.split('/'):
        if not part:
            # strip empty path components
            continue
        
        drive, part = os.path.splitdrive(part)
        head, part = os.path.split(part)
        if part in (os.curdir, os.pardir):
            # strip '.' amd '..' in path
            continue
        
        newpath = os.path.join(newpath, part).replace('\\', '/')

Django itself doesn't read files (unless you use the ``static.serve``
function, but that's protected with the code shown above), so this
vulnerability doesn't affect the core code much.

In addition, the use of the URLconf abstraction means that Django will *never*
load code you've not explicitly told it to load. There's no way to create a
URL that causes Django to load something not mentioned in a URLconf.

Exposed error messages
======================

Django's philosophy is that site visitors should never see application-related
error messages. If your code raises an unhandled exception, a site visitor
should not see the full traceback -- or *any* hint of code snippets or Python
(programmer-oriented) error messages. Instead, the visitor should see a
friendly "This page is unavailable" message.

Any code errors and tracebacks displayed to the public could give valuable
insight to a malicious hacker.

Naturally, of course, developers need to see tracebacks to debug problems in
their code. So the framework should hide all error messages from the public,
but it should display them to the trusted site developers.

The solution
------------

    * DEBUG=False
    * 404/500 templates
    * PythonDebug Off (modpy)
    * FCGI errors?

