========
Security
========

The internet can be a scary place.

In the past few years, internet horror stories have been in the news almost
continuously. We've seen viruses spread with amazing speed, swarms of
compromised computers wielded as weapons, a never-ending arms race against
spammers, and many, many reports of identify theft from compromised web sites.

As good web developers, it's our duty to do what we can to combat these forces
of darkness. Every web developer needs to treat security as a fundamental
aspect of web programming. Unfortunately, it turns out that security is *hard*
-- attackers only need to find a single vulnerability, but defenders have to
protect every single one.

Django attempts to mitigate this difficulty; it's designed to automatically
protect you from many of the common security mistakes that new (and even
experienced) web developers make. Still, it's important to understand what
these problems are, how Django protects you, and -- most importantly -- the
steps you can take to make your code even more secure.

First, though, an important disclaimer: we're in no way experts in this realm,
and so we won't try to explain each vulnerability in a comprehensive manner.
Instead, we'll give a short synopsis of security problems as they apply to
Django. For those interested in a more in-depth discussion of web security, we
recommend XXX.

SQL injection
=============

SQL injection is a common exploit in which an attacker alters Web-page
parameters (such as GET/POST data or URLs) to insert arbitrary SQL snippets
that a naive Web application executes in its database directly.

This vulnerability most commonly crops up when constructing SQL "by hand" from
user input. For example, imagine writing a function to gather a list of a
contact info from a contact search page. To prevent spammers from reading
every single email in our system, we'll force the user to type in someone's
username before we provide their email address::

    def user_contacts(request):
        user = request.GET['username']
        sql = "SELECT * FROM user_contacts WHERE username = '%s';" % username
        # execute the SQL here...
        
.. note::

    In this example, and all similar "don't do this" examples that follow,
    we've deliberately left out most of the code needed to make the functions
    actually work. We don't want this code to work if someone accidentally
    takes it out of context.
    
Though at first this doesn't look dangerous, it's really is. First, our
attempt at protecting our entire email list will fail with a cleverly
constructed query.

Think about what happens if an attacker types ``"' OR 'a'='a"`` into the query
box. In that case, the query that the string interpolation will construct will
be::

    SELECT * FROM user_contacts WHERE username = '' OR 'a' = 'a';
    
Because we allowed unsecured SQL into the string, the attacker's added ``OR``
clause ensures that every single row is returned.

However, that's the *least* scary attack. Imagine what will happen if the
attacker submits ``"'; DELETE FROM user_contacts WHERE 'a' = 'a``". We'll end
up with this complete query::

    SELECT * FROM user_contacts WHERE username = ''; DELETE FROM user_contacts WHERE 'a' = 'a';
    
Yikes! Where'd our contact list go?

The solution
------------

Although this problem is insidious and sometimes hard to spot, the solution is
simple: *never* trust user-submitted data, and *always* escape it when passing
it into SQL.

The Django database API does this for you. It automatically escapes all
special SQL parameters, according to the quoting conventions of the database
server you're using (e.g. PostgreSQL, MySQL).

For example, in this API call::

    foo.get_list(bar__exact="' OR 1=1")

Django will escape the input accordingly, resulting in a statement like this::

    SELECT * FROM foos WHERE bar = '\' OR 1=1'
    
Which is harmless.

This applies to the entire Django database API, with a couple of exceptions:

    * The ``where`` argument to the ``extra()`` method (see Appendix XXX).
      That parameter accepts raw SQL by design.

    * Queries done "by hand" using the lower-level database API.

In each of these cases, it's easy to keep yourself protected. In each case,
avoid string interpolation in favor of passing in "bind parameters". That is,
the example we started this section with should be written::

    from django.db import connection

    def user_contacts(request):
        user = request.GET['username']
        sql = "SELECT * FROM user_contacts WHERE username = %s"
        cursor = connection.cursor()
        cursor.execute(sql, [user])
        # ... do something with the results
        
The low-level ``execute`` method takes a SQL string with ``%s`` placeholders,
and automatically escapes and inserts parameters from the list passed as the
second argument. You should *always* construct custom SQL this way.

E-mail header injection
=======================

[3:15pm] adrian_h: send_mail() constructs the e-mail message using the subject, message, etc. and pieces together the headers
[3:16pm] adrian_h: So if you passed subject='hello\nCc:spamvictim@example.com', that's an example of a header injection
[3:16pm] adrian_h: Using headers to spam, basically
[3:16pm] jacobkm: aah, ok
[3:16pm] jacobkm: but send_mail actually escapes \n, right?
[3:16pm] adrian_h: We prevent that by disallowing newlines in the appropriate fields in send_mail() -- have a look at the source for more details
[3:16pm] jacobkm: right, OK
[3:16pm] adrian_h: I think it just disallows rather than escapes


Exposed error messages
======================

The problem
-----------

Django's philosophy is that site visitors should never see application-related
error messages. If your code raises an unhandled exception, a site visitor
should not see the full traceback -- or *any* hint of code snippets or Python
(programmer-oriented) error messages. Instead, the visitor should see a
friendly "This page is unavailable" message.

Any code errors and tracebacks displayed to the public could give valuable
insight to a malicious hacker.

Naturally, of course, developers need to see tracebacks to debug problems in
their code. So the framework should hide all error messages from the public,
but it should display them to the trusted site developers.

The solution
------------

Cross-site Scripting (XSS)
==========================

More
================

[3:19pm] adrian_h: Hmm..
[3:20pm] jacobkm: probably something about man-in-the-middle session attacks (which can only really be stopped by using https)
[3:20pm] adrian_h: Session stuff -- essentially an explanation of how sessions are tied to a session cookie and it's relying solely on unguessability of the session ID
[3:20pm] jacobkm: Yeah
[3:21pm] adrian_h: There's really no way around that unless you also key it on IP address or user agent, but there are problems with those approaches -- maybe it could discuss that
[3:21pm] jacobkm: yup
[3:22pm] jacobkm: I think I'm more or less gonna say that if you want to be really protected from that stuff that you'll need to use ssl
[3:22pm] adrian_h: One thing we do as an extra security precaution is reset the session key if an attempt is made to guess it -- see line 60 in contrib/sessions/middleware.py
[3:22pm] jacobkm: right, yeah
[3:22pm] jacobkm: that's smart :)
[3:23pm] adrian_h: http://en.wikipedia.org/wiki/Category:Web_security_exploits
[3:23pm] jacobkm: Ooh, that's a good place to start
[3:23pm] adrian_h: There are a couple of links on this ticket, too -- http://code.djangoproject.com/ticket/362
[3:24pm] jacobkm: oh, X-Forwarded-For needs a mention, too
[3:24pm] adrian_h: Also, our session framework intentionally doesn't allow for session IDs to be passed in URLs, because that's an exploit waiting to happen
[3:24pm] jacobkm: Right
[3:24pm] adrian_h: This is going to be a fun chapter!
[3:24pm] jacobkm: I think I mentioned that in the sessions chapter.
[3:24pm] jacobkm: Heh
[3:25pm] adrian_h: We already have a section about the CSRF middleware (in the contrib chapter), but you could just mention that again, with a pointer to that chapter
[3:25pm] jacobkm: right