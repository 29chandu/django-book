=======================================
Chapter 11: Generating non-HTML content
=======================================

Usually when we talk about developing web sites, we're talking about producing
some flavor of HTML. Of course, there's a lot more to the web than HTML,
though; we use the web to distribute all kinds of content, not just HTML.

Until this point, we've focused just on the common case of HTML production,
but in this chapter we'll take a detour and look at using Django to produce
other types of content.

Django has convenient built-in tools that you can use to produce some common
non-HTML content:

    * RSS/Atom syndication feeds.
    * Sitemaps -- consumed by Google, Yahoo and Microsoft's search engines.
    * JSON and XML serialized representations of models (usually used for AJAX
      functions).
            
We'll cover each of those tools a little later on, but first, some basics.

The basics
==========

Remember this from Chapter 3?

    A view function, or view for short, is simply a Python function that takes
    a Web request and returns a Web response. This response can be the HTML
    contents of a Web page, or a redirect, or a 404 error, or an XML document,
    or an image...or anything, really.
    
More formally, a Django view function *must*:

    * Accept an ``HttpRequest`` instance as its first argument, and
    * return an ``HttpResponse`` instance.
    
The key to returning non-HTML content from a view lies in the ``HttpResponse``
class, and specifically the ``mimetype`` constructor argument. By tweaking the
mime-type, we can indicate to the browser that we've returned an object of a
different type.

For a very simple example, let's look at a view that returns a PNG image. To
keep things simple, we'll just read the file off the disk::

    from django.http import HttpResponse
    
    def my_image(request):
        image_data = open("/path/to/my/image.png", "rb").read()
        return HttpResponse(image_data, mimetype="image/png")
        
That's it! If you replace the image path in the ``open()`` call with a path to
a real image, you can use this very simple view to serve an image, and the
browser will display it correctly.

The other important thing to keep in mind is that ``HttpResponse`` objects
implement Python's standard file API. This means that you can pass in an
``HttpResponse`` instance to any place Python (or a third-party library)
expects a file.

For an example of how that works, let's take a look at producing CSV with
Django.

Producing CSV
=============

CSV is a simple data format usually used by spreadsheet software. It's
basically a series of table rows, with each cell in the row separated by
commas (CSV stands for "Comma Separated Values"). For example, here's a list
of the number of "unruly" airline passengers over the last 10 years, as
compiled by the FAA::

    Year,Unruly Airline Passengers
    1995,146
    1996,184
    1997,235
    1998,200
    1999,226
    2000,251
    2001,299
    2002,273
    2003,281
    2004,304
    2005,203

.. note::

    See http://www.faa.gov/data_statistics/passengers_cargo/unruly_passengers/
    for the source of this data.

Unfortunately, CSV It's not a format that's ever been formally defined;
different pieces of software produce and consume different variants of CSV,
making it a bit tricky to use. Luckily, Python comes with a standard CSV
library, ``csv``, that is pretty much bulletproof.

The key to using this library with Django is that the ``csv`` module's
CSV-creation capability acts on file-like objects, and Django's
``HttpResponse`` objects are file-like objects::

    import csv
    from django.http import HttpResponse

    # Number of unruly passengers each year 1995 - 2005
    UNRULY_PASSENGERS = [146,184,235,200,226,251,299,273,281,304,203]

    def unruly_passengers_csv(request):
        # Create the HttpResponse object with the appropriate CSV header.
        response = HttpResponse(mimetype='text/csv')
        response['Content-Disposition'] = 'attachment; filename=unruly.csv'

        # Create the CSV writer using the HttpResponse as the "file"
        writer = csv.writer(response)
        writer.writerow(['Year', 'Unruly Airline Passengers'])
        for (year, num) in zip(range(1995, 2006), UNRULY_PASSENGERS):
            writer.writerow([year, num])

        return response
    
The code and comments should be pretty clear, but a few things deserve a
mention:

    * The response is given the ``text/csv`` mime-type. This tells
      browsers that the document is a CSV file, rather than an HTML file.

    * The response gets an additional ``Content-Disposition`` header, which
      contains the name of the CSV file. This header (well, the "attachment"
      part) will instruct the browser to prompt for a location to save the
      file (instead of just displaying it). This filename is arbitrary; call
      it whatever you want. It'll be used by browsers in the "Save as..."
      dialogue

    * Hooking into the CSV-generation API is easy: Just pass ``response`` as
      the first argument to ``csv.writer``. The ``csv.writer`` function
      expects a file-like object, and ``HttpResponse`` objects fit the bill.

    * For each row in your CSV file, call ``writer.writerow``, passing it an
      iterable object such as a list or tuple.

    * The CSV module takes care of quoting for you, so you don't have to worry
      about escaping strings with quotes or commas in them. Just pass
      information to ``writerow()``, and it'll do the right thing.

You'll usually repeat this pattern -- create an ``HttpResponse`` response
object (with a special mime-type), pass it to something expecting a file, then
return the response -- any time you generate non-HTML content.

Let's look at a few more examples:

Generating PDFs
===============

PDF (Portable Document Format) is a format developed by Adobe that's used to
represent printable documents, complete with pixel-perfect formatting,
embedded fonts, and 2D vector graphics. You can think of a PDF document as the
digital equivalent of a printed document; indeed, PDFs are usually used when
you need to give a document to someone else to print.

You can easily generate PDFs with Python and Django thanks to the excellent
excellent open-source ReportLab library
(http://www.reportlab.org/rl_toolkit.html).

The advantage of generating PDF files dynamically is that you can create
customized PDFs for different purposes -- say, for different users or
different pieces of content.

For example, we used Django and ReportLab at KUSports.com to generate
customized, printer-ready NCAA tournament brackets for people participating in
a March Madness (college basketball) contest.

Installing ReportLab
--------------------

Before you do any PDF generation, however, you'll need to install ReportLab.
It's usually pretty simple: just download and install the library from
http://www.reportlab.org/downloads.html.

The user guide (not coincidentally, a PDF file) at
http://www.reportlab.org/rsrc/userguide.pdf has additional help on
installation.

.. note::

    If you're using a modern Linux distribution, you might want to check your 
    package management utility before installing ReportLab by hand; most 
    package repositories have added ReportLab.
    
    For example, if you're using the (excellent) Ubuntu distribution, a simple
    ``aptitude install python-reportlab`` will do the trick nicely.

Test your installation by importing it in the Python interactive interpreter::

    >>> import reportlab

If that command doesn't raise any errors, the installation worked.

Writing your view
-----------------

Again, key to generating PDFs dynamically with Django is that the ReportLab
API acts on file-like objects, and Django's ``HttpResponse`` objects are
file-like objects.

Here's a "Hello World" example::

    from reportlab.pdfgen import canvas
    from django.http import HttpResponse

    def hello_pdf(request):
        # Create the HttpResponse object with the appropriate PDF headers.
        response = HttpResponse(mimetype='application/pdf')
        response['Content-Disposition'] = 'attachment; filename=hello.pdf'

        # Create the PDF object, using the response object as its "file."
        p = canvas.Canvas(response)

        # Draw things on the PDF. Here's where the PDF generation happens.
        # See the ReportLab documentation for the full list of functionality.
        p.drawString(100, 100, "Hello world.")

        # Close the PDF object cleanly, and we're done.
        p.showPage()
        p.save()
        return response

Like above, a few notes are in order:

    * Here we use the ``application/pdf`` mime-type. This tells
      browsers that the document is a PDF file, rather than an HTML file. If
      you leave this off, browsers will probably interpret the output as HTML,
      which will result in scary gobbledygook in the browser window.

    * Hooking into the ReportLab API is easy: Just pass ``response`` as the
      first argument to ``canvas.Canvas``. The ``Canvas`` class expects a
      file-like object, and ``HttpResponse`` objects fit the bill.

    * All subsequent PDF-generation methods are called on the PDF
      object (in this case, ``p``) -- not on ``response``.

    * Finally, it's important to call ``showPage()`` and ``save()`` on the PDF
      file (or else you'll end up with a corrupted PDF file).

Complex PDFs
------------

If you're creating a complex PDF document with ReportLab, consider using the
``cStringIO`` library as a temporary holding place for your PDF file. The
``cStringIO`` library provides a file-like object interface that is
particularly efficient (much more so than the naive ``HttpResponse``-as-file
implementation). 

Here's the above "Hello World" example rewritten to use ``cStringIO``::

    from cStringIO import StringIO
    from reportlab.pdfgen import canvas
    from django.http import HttpResponse

    def hello_pdf(request):
        # Create the HttpResponse object with the appropriate PDF headers.
        response = HttpResponse(mimetype='application/pdf')
        response['Content-Disposition'] = 'attachment; filename=hello.pdf'

        buffer = StringIO()

        # Create the PDF object, using the StringIO object as its "file."
        p = canvas.Canvas(buffer)

        # Draw things on the PDF. Here's where the PDF generation happens.
        # See the ReportLab documentation for the full list of functionality.
        p.drawString(100, 100, "Hello world.")

        # Close the PDF object cleanly.
        p.showPage()
        p.save()

        # Get the value of the StringIO buffer and write it to the response.
        response.write(buffer.getvalue())
        return response
       
Other possibilities
===================

There's a whole world of other types of content you can generate in Python.
Here are a few more ideas, and some pointers to libraries you could use to
implement them:

    * **Generating ZIP files**: Python's standard library ships with the
      ``zipfile`` module, which can both read and write compressed ZIP files.
      You could use it to provide on-demand archives of a bunch of files, or
      perhaps compress large documents when requested. You could similarly
      produce TAR files using the standard library ``tarfile`` module.

    * **Dynamic image generation**: the Python Imaging Library
      (http://www.pythonware.com/products/pil/) is a fantastic toolkit for
      producing images (PNG, JPEG, GIF, and a whole lot more). You could use
      it to automatically scale down images into thumbnails, composite
      multiple images into a single frame, or even do web-based image
      processing.

    * **Plots and charts**: there are a number of incredibly powerful Python
      plotting and charting libraries you could use to produce on-demand maps,
      charts, plots, and graphs. We can't possibly list them all, so here are
      a couple of the highlights:
    
        * ``matplotlib`` (http://matplotlib.sourceforge.net/), which can be
          used to produce the type of high-quality plots usually generated
          with MatLab or Mathematica.

        * ``pygraphviz`` (https://networkx.lanl.gov/wiki/pygraphviz), an
          interface to the Graphviz graph layout toolkit
          (http://graphviz.org/), used for generating structured diagrams of
          graphs and networks.

In general, any Python library capable of writing to a file can be hooked into
Django; the possibilities really are endless.

Django's built-in content generation tools
==========================================

(intro)

Syndication feeds
-----------------

Take from syndication doc

Sitemaps
--------

Take from sitemaps doc -- make sure to mention it's not Google any more.

Serialized objects
------------------

- view examples
- JSON format
- XML format
