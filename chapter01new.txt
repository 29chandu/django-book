=====================================
Chapter 1: Welcome to the Django Book
=====================================

This book is about Django, a Web development framework that saves you time
and makes Web development a joy. Using Django, you can build and maintain
high-quality Web applications with minimal fuss.

At its best, Web development is an exciting, creative act; at its worst,
it can be a repetitive, frustrating nuisance. Django lets you focus on the fun
stuff -- the meat of your Web application -- while easing the pain of the
repetitive bits. In doing so, it provides high-level abstractions of common
Web development patterns, shortcuts for frequent programming tasks and
clear conventions on how to solve problems. At the same time, Django tries to
stay out of your way, letting you work outside the scope of the framework as
needed.

The goal of this book is to make you a Django expert. The focus is twofold.
First, we intend to explain, in depth, what Django does and how to build Web
apps with it. Second, we will try to discuss higher-level concepts where
appropriate, answering the question, "How can I apply these tools effectively
in my own projects?" By reading this book, you'll learn the skills needed to
develop powerful Web sites quickly, with code that is clean and easy to
maintain.

Web frameworks
==============

Django is a prominent member of a new generation of "Web frameworks." What,
exactly, does that term mean?

To answer that question, let's consider the design of a Web application written
using the CGI (Common Gateway Interface) standard, a popular way to write Web
apps circa 1998. In those days, when you wrote a CGI application, you did
everything yourself -- the equivalent of baking a cake from scratch. For
example, here's a simple CGI script, written in Python, that displays the 10
most recently published books from a database::

    #!/usr/bin/python

    import MySQLdb

    print "Content-Type: text/html"
    print
    print "<html><head><title>Books</title></head>"
    print "<body>"
    print "<h1>Books</h1>"
    print "<ul>"

    connection = MySQLdb.connect(user='me', passwd='letmein', db='my_db')
    cursor = connection.cursor()
    cursor.execute("SELECT name FROM books ORDER BY pub_date DESC LIMIT 10")
    for row in cursor.fetchall():
        print "<li>%s</li>" % row[0]

    print "</ul>"
    print "</body></html>"

    connection.close()

This code is straightforward. First, it prints a "Content-Type" line, followed
by a blank line, as required by CGI. It prints some introductory HTML, then
connects to a database and executes a query that retrieves the latest 10 books.
Looping over those books, it generates an HTML unordered list. Finally, it
prints the closing HTML and closes the database connection.

With a one-off dynamic page such as this one, the write-it-from-scratch
approach isn't necessarily bad. For one thing, this code is simple to
comprehend -- a developer can read these 16 lines of Python and understand all
it does, from start to finish. There's nothing else to learn, no other code to
read. It's also simple to deploy -- just save this code in a file called
``latestbooks.cgi``, upload that file to a Web server and visit that page with
a browser.

But as a Web application grows beyond the trivial, this write-it-from-scratch
approach breaks down, and you're faced with a number of problems:

    * What happens when multiple pages need to connect to the database? Surely
      that database-connecting code shouldn't be duplicated in each individual
      CGI script, so the pragmatic thing to do would be to refactor it into a
      function.

    * Should a developer *really* have to worry about printing the
      "Content-Type" line and remembering to close the database connection?
      This sort of boilerplate reduces programmer productivity and introduces
      opportunities for mistakes. These setup- and teardown-related tasks would
      best be handled by some common infrastructure.

    * What happens when this code is reused in multiple environments, each with
      a separate database and password? At this point, some
      environment-specific configuration becomes essential.

    * What happens when a Web designer, who has no knowledge of programming,
      wishes to redesign the page? Ideally, the logic of the page -- the
      retrieval of books from the database -- would be separate from the
      display of the page, so that a designer could edit the latter without
      affecting the former.

These problems are precisely what a Web framework intends to solve. A Web
framework provides a programming infrastructure for your applications, so that
you can focus on writing clean, maintainable code without having to reinvent
the wheel. In a nutshell, that's what Django does.

The MVC design pattern
======================

Here's how one might write the previous CGI code using Django::

    # models.py (the database tables)

    from django.db import models

    class Book(models.Model):
        name = models.CharField(maxlength=50)
        pub_date = models.DateField()


    # views.py (the business logic)

    from django.shortcuts import render_to_response
    from models import Book

    def latest_books(request):
        book_list = Book.objects.order_by('-pub_date')[:10]
        return render_to_response('latest_books.html', {'book_list': book_list})


    # urls.py (the URL configuration)

    from django.conf.urls.defaults import *
    import views

    urlpatterns = patterns('',
        (r'latest/$', views.latest_books),
    )


    # latest_books.html (the template)

    <html><head><title>Books</title></head>
    <body>
    <h1>Books</h1>
    <ul>
    {% for book in book_list %}
    <li>{{ book.name }}</li>
    {% endfor %}
    </ul>
    </body></html>

Don't worry about the particulars of *how* this works just yet -- just get a
feel for the overall design. The main thing to note here is the
*separation of concerns.*

    * The ``models.py`` file contains a description of the database table, as a
      Python class. This is called a **model**. Using this class, you can
      create, retrieve, update and delete records in your database using simple
      Python code rather than writing repetitive SQL.

    * The ``views.py`` file contains the business logic for the page, in the
      ``latest_books()`` function. This function is called a **view**.

    * The ``urls.py`` file specifies which view is called for a given URL
      pattern. In this case, the URL ``/latest/`` will be handled by the
      ``latest_books()`` function.

    * The ``latest_books.html`` is an HTML template that describes the design
      of the page.

Taken together, these pieces loosely follow the MVC (Model-View-Controller)
design pattern. Simply put, this is a way of developing software so that the
code for defining and accessing data (the model) is separate from request
routing logic (the controller), which in turn is separate from the user
interface (the view).

A key advantage of such an approach is that components are loosely coupled.
That is, each distinct piece of a Django-powered Web application has a single
key purpose and can be changed independently without affecting the other
pieces. For example, a developer can change the URL for a given part of the
application without affecting the underlying implementation. A designer can
change a page's HTML without having to touch the Python code that renders it.
A database administrator can rename a database table and make the change in a
single place.

In this book, each component of this stack gets its own chapter. For example,
Chapter 3 covers views, Chapter 4 covers templates and Chapter 5 covers models.
Chapter 5 also discusses Django's MVC philosophies in depth.

Django's history
================

Before we dive into more code, we should take a moment to explain Django's
history. It's helpful to understand why the framework was created, along with
the background of its developers.

If you've been building Web applications for a while, the problems with the CGI
example we presented above probably sound familiar. The classic Web developer's
path goes something like this:

    1. Write a Web app from scratch
    2. Write another Web app from scratch
    3. Realize the app from step 1 shares much in common with the app from step 2
    4. Refactor the code so that app 1 shares code with app 2
    5. Repeat steps 2-4 several times
    6. Realize you've invented a framework

This is precisely how Django itself was created!

Django grew organically from real-world applications written by a Web
development team in Lawrence, Kansas, USA. It was born in fall 2003, when the
Web programmers at the Lawrence Journal-World newspaper, Adrian Holovaty and
Simon Willison, began using Python instead of PHP to build applications. The
World Online team, responsible for the production and maintenance of several
local news sites, thrived in a development environment dictated by journalism
deadlines. For the sites -- including LJWorld.com, Lawrence.com and KUsports.com
-- journalists (and management) demanded that features be added on an intensely
fast schedule, often with only days' or hours' notice. Thus, Adrian and Simon
developed a timesaving Web development framework almost out of necessity -- it
was the only way they could build maintainable applications under the extreme
deadlines.

In summer 2005, after having developed this framework to a point where it was
efficiently powering most of World Online's sites, the World Online team, which
now included Jacob Kaplan-Moss, decided to release the framework open-source.
They open-sourced it in July 2005, naming it Django, after the jazz guitarist
Django Reinhardt.

Although Django is now an open-source project with contributors across the
planet, the original World Online developers still provide central guidance
for the framework's growth, and World Online contributes other important
aspects such as employee time, marketing materials and hosting/bandwidth for
the framework's Web site (http://www.djangoproject.com/).



#######################################
# EVERYTHING UNDER THIS IS JUST NOTES #
#######################################



A high-level introduction to Django
===================================

At its core, Django is simply a collection of libraries written in the Python
programming language. To develop a site using Django, you write Python code
that uses these libraries.

These libraries provide a wealth of Web development functionality -- ranging
from low-level matters, such as HTTP transactions and database connections, to
high-level abstractions, such as automatic HTML form display and SQL generation.
The value of Django is its slick integration of these libraries into a full
package. Sure, you could write Web applications by piecing together your own
components, starting from scratch, as we did in the days of CGI (and as many
developers do today with PHP), but Django provides an infrastructure so you
don't have to write it yourself.










Because Django's developers have worked hard on making sure each level
of the "stack" works well with the next,







-- in a way that is conveniently integrated but loosely coupled.


The value of Django is its integration of these libraries, along with its conventions.
Community.


At its core, Django is simply a collection of libraries written in the Python
programming language. To develop a site using Django, you write Python code
that uses these libraries. Learning Django, then, is a matter of learning how
to program in Python and learning how the Django libraries work.

If you have experience programming in Python, you should have no trouble diving
in; by and large, the Django code doesn't perform "black magic" -- i.e.
programming trickery whose implementation is difficult to explain or
understand. For you, learning Django will be a matter of learning Django's
conventions and APIs.

If you don't have experience programming in Python, you're in for a treat.
Django is a great reason
















 It's just Python, and Django applications have a high
"understandability" factor -- that is, given the code to a Django app, it's
easy to read it





Python is a beautiful, concise, powerful, high-level programming language.


 To develop a site using Django, you write Python code
that uses the Django libraries. Although this book doesn't include a full
Python tutorial, it highlights Python features and functionality where
appropriate, particularly when code doesn't immediately make sense.



Dynamic Web sites
=================







We can't stress this point enough: Under the hood, Django is just Python.

Here's an example Python function:

    def say_hello():
        print 'Hello world'

And here's an example Python function that creates a Web page using Django:

    from django.http import HttpResponse

    def say_hello(request):
        return HttpResponse('Hello world')






This statement cannot be stressed enough: It's just Python!



What does Django do? The best way to answer this question is to look at Web sites.

Let's start at square one. Django makes dynamic Web sites.



In order to explain


For clarity, a dynamic Web site is one in which pages aren't simply
HTML documents sitting on a server's filesystem somewhere. In a
dynamic Web site, rather, each page is generated by a computer program -- a
so-called "Web application" -- that you, the Web developer, create. A Web
application may, for instance, retrieve records from a database or take some
action based on user input.





Open-source
===========

Django is an open-source project. You can contribute.



Intended audience
=================

Although this book doesn't include a full
Python tutorial, it highlights Python features and functionality where
appropriate, particularly when code doesn't immediately make sense.
