==============================================
Chapter 5: Interacting with a database: Models
==============================================

In Chapter 3, we covered the fundamentals of building dynamic Web sites
with Django: setting up views and URLconfs. As we explained, a view is
responsible for doing *some arbitrary logic*, then returning a response. In the
example, our *arbitrary logic* was to calculate the current date and time.

In many modern Web applications, the *arbitrary logic* involves interacting
with a database. Behind the scenes, a so-called **database-driven Web site**
connects to a database server, retrieves some data out of it and displays that
data, nicely formatted, on a Web page. Or, similarly, the site could provide
functionality that lets site visitors populate the database on their own.

Many complex Web sites provide some combination of the two. Amazon.com, for
instance, is a great example of a database-driven site. Each product page is
essentially an HTML view into Amazon's product database, and when you post a
customer review, it gets inserted into the database of reviews.

Django is very well-suited for making database-driven Web sites, as it comes
with easy yet powerful ways of performing database queries using Python. This
chapter explains that functionality -- Django's database layer.

(Note: While it's not strictly necessary to know basic database theory and SQL
in order to use Django's database layer, it's highly recommended. An
introduction to those concepts is out of the scope of this book, but keep
reading even if you're a database newbie. You'll probably be able to follow
along and grasp concepts based on context.)

The "dumb" way to do database queries in views
==============================================

Just as the previous chapter detailed a "dumb" way to output HTML within a
view (by hard-coding HTML directly within the view), there's a "dumb" way to
retrieve data from a database in a view. It's simple: Just use any existing
Python library to execute an SQL query and do something with the results.

In this example, we use the ``MySQLdb`` library (available at
http://sourceforge.net/projects/mysql-python) to connect to a MySQL database,
retrieve some records and feed them to a template for display as a Web page::

    from django.shortcuts import render_to_response
    import MySQLdb

    def book_list(request):
        db = MySQLdb.connect(user='me', db='mydb', passwd='secret', host='localhost')
        cursor = db.cursor()
        cursor.execute('SELECT name FROM books ORDER BY name')
        names = [row[0] for row in cursor.fetchall()]
        db.close()
        return render_to_response('book_list.html', {'names': names})

This approach works, but some problems should jump out at you immediately:

    * We're hard-coding the database connection parameters. Ideally, these
      parameters would be stored in the Django configuration.

    * We're having to write a fair bit of boilerplate code: creating a
      connection, creating a cursor, executing a statement and closing the
      connection. Ideally, all we'd have to do is specify which results we
      wanted.

    * It ties us to MySQL. If, down the road, we switch from MySQL to
      PostgreSQL, we'll have to use a different database adapter (e.g.,
      ``psycopg`` rather than ``MySQLdb``), alter the connection parameters
      and -- depending on the nature of the SQL statement -- possibly rewrite
      the SQL. Ideally, the database server we're using would be abstracted, so
      that a database server change could be made in a single place.

As you might expect, Django's database layer aims to solve these problems.
Here's a sneak preview of how the above view can be rewritten using Django's
database API::

    from django.shortcuts import render_to_response
    from mysite.books.models import Book

    def book_list(request):
        books = Book.objects.order_by('name')
        return render_to_response('book_list.html', {'books': books})

We'll explain this code a little later in this chapter. For now, just get a
feel for how it looks.

The MTV development pattern
===========================

Before we delve into any more code, let's take a moment to consider the overall
design of a database-driven Django Web application.

As we've mentioned in previous chapters, Django is designed to encourage loose
coupling and strict separation between pieces of an application. If you follow
this philosophy, it's easy to make changes to one particular piece of the
application without affecting other pieces of the application. In view
functions, for instance, we discussed the importance of separating the business
logic from the presentation logic by using a template system. With the database
layer, we're applying that same philosophy to data-access logic.

Those three pieces together -- data-access logic, business logic and presentation
logic -- comprise a concept that's sometimes called the "Model View Controller"
(MVC) pattern of software architecture. In this pattern, "Model" refers to the
data-access layer, "View" refers to the part of the system that selects what to
display and how to display it, and "Controller" refers to the part of the
system that decides which view to use, depending on user input, accessing the
model as needed.

.. admonition:: Why the acronym?

    MVC? MTV? What's the point of these terms?

    The goal of explicitly defining patterns such as MVC is mostly to
    streamline communication among developers. Instead of having to tell your
    coworkers, "Let's make an abstraction of the data-access, then have a
    separate layer that handles data display, and let's put a layer in the
    middle that regulates this," you can take advantage of a shared vocabulary
    and say, "Let's use the MVC pattern here."

Django follows this MVC pattern closely enough that it can be called an MVC
framework. Here's roughly how the M, V and C break down in Django:

    * **M**, the data-access portion, is handled by Django's database layer,
      which is described in this chapter.

    * **V**, the portion that selects which data to display and how to displapy
      it, is handled by views and templates.

    * **C**, the portion that delegates to a view depending on user input, is
      handled by the framework itself by following your URLconf and calling the
      appropriate Python function for the given URL.

Because the "C" is handled by the framework itself and most of the excitement
in Django happens in models, templates and views, Django has been referred to
as an **MTV framework**. In the so-called MTV development pattern,

    * "M" stands for model, the data-access layer.

    * "T" stands for template, the presentation layer.

    * "V" stands for view, the business-logic layer.

If you're familiar with other MVC Web-development frameworks, such as Ruby on
Rails, you may consider Django views to be the "controllers" and Django
templates to be the "views." This is an unfortunate confusion brought about by
differing interpretations of MVC. In Django's interpretation of MVC, the "view"
describes the data that gets presented to the user; it's not necessarily *how*
the data looks, but *which* data is presented. In contrast, Ruby on Rails and
similar frameworks suggest that the controller's job includes deciding which
data gets presented to the user, whereas the view is strictly *how* the data
looks, not *which* data is presented.

Neither interpretation is more "correct" than the other. The important thing is
to understand the underlying concepts.

Configuring the database
========================

With all of that philosophy in mind, let's start exploring Django's database
layer. First, we need to take care of some initial configuration; we need to
tell Django which database server to use and how to connect to it.

We'll assume you've set up a database server, activated it and created a
database within it (e.g., using a ``CREATE DATABASE`` statement). SQLite is a
special case; in that case, there's no database to create, because SQLite uses
standalone files on the filesystem to store its data.

As ``TEMPLATE_DIRS`` in the previous chapter, database configuration lives in
the Django settings file, called ``settings.py`` by default. Edit that file and
look for the database settings::

    DATABASE_ENGINE = ''
    DATABASE_NAME = ''
    DATABASE_USER = ''
    DATABASE_PASSWORD = ''
    DATABASE_HOST = ''
    DATABASE_PORT = ''

Here's a rundown of each setting.

    * ``DATABASE_ENGINE`` tells Django which database engine to use. If you're
      using a database with Django, ``DATABASE_ENGINE`` must be set to one of
      the following strings::

          =======================  ====================  ==============================================
          Setting                  Database              Required adapter
          =======================  ====================  ==============================================
          ``postgresql``           PostgreSQL            ``psycopg`` version 1.x,
                                                         http://initd.org/projects/psycopg1
          ``postgresql_psycopg2``  PostgreSQL            ``psycopg`` version 2.x,
                                                         http://initd.org/projects/psycopg2
          ``mysql``                MySQL                 ``MySQLdb``,
                                                         http://sourceforge.net/projects/mysql-python
          ``sqlite3``              SQLite                No adapter needed if using Python 2.5+.
                                                         Otherwise, ``pysqlite``,
                                                         http://initd.org/tracker/pysqlite
          ``ado_mssql``            Microsoft SQL Server  ``adodbapi`` version 2.0.1+,
                                                         http://adodbapi.sourceforge.net/
          ``oracle``               Oracle                ``cx_Oracle``,
                                                         http://www.python.net/crew/atuining/cx_Oracle/
          =======================  ====================  ==============================================

      Note that for whichever database backend you use, you'll need to download
      and install the appropriate database adapter. Each one is available for
      free on the Web.

    * ``DATABASE_NAME`` tells Django what the name of your database is. If
      you're using SQLite, specify the full filesystem path to the database
      file on your filesystem.

    * ``DATABASE_USER`` tells Django which username to use when connecting to
      your database. If you're using SQLite, leave this blank.

    * ``DATABASE_PASSWORD`` tells Django which password to use when connecting
      to your database. If you're using SQLite or have an empty password, leave
      this blank.

    * ``DATABASE_HOST`` tells Django which host to use when connecting to your
      database. If your database is on the same computer as your Django
      installation (i.e., localhost), leave this blank. If you're using SQLite,
      leave this blank.

      MySQL is a special case here. If this value starts with a forward slash
      (``'/'``) and you're using MySQL, MySQL will connect via a Unix socket to
      the specified socket. For example::

          DATABASE_HOST = '/var/run/mysql'

      If you're using MySQL and this value *doesn't* start with a forward
      slash, then this value is assumed to be the host.

    * ``DATABASE_PORT`` tells Django which port to use when connecting to your
      database. If you're using SQLite, leave this blank. Otherwise, if you
      leave this blank, the underlying database adapter will use whichever
      port is default for your given database server. In most cases, the
      default port is fine, so you can leave this blank.

Once you've entered those settings, test your configuration. First, from within
the ``mysite`` project directory you created in Chapter 2, run the command
``python manage.py shell``.

You'll notice this starts a Python interactive interpreter. Looks can be
deceiving, though! There's an important difference between running the command
``python manage.py shell`` within your Django project directory and the more
generic ``python``. The latter is the basic Python shell, but the former tells
Django which settings file to use before it starts the shell. This is a key
requirement for doing database queries: Django needs to know which settings
file to use in order to get your database connection information.

Behind the scenes, ``python manage.py shell`` sets the environment variable
``DJANGO_SETTINGS_MODULE``. We'll cover the subtleties of this later, but for
now, just know that you should use ``python manage.py shell`` whenever you need
to drop into the Python interpreter to do Django-specific tinkering.

Once you've entered the shell, type these commands to test your database
configuration::

    >>> from django.db import connection
    >>> cursor = connection.cursor()

If nothing happens, then your database is configured properly. Otherwise, check
the error message for clues about what's wrong. Here are some common errors::

    ======================================  ==========================================
    Error message                           Solution
    ======================================  ==========================================
    ``You haven't set the DATABASE_ENGINE   Set the ``DATABASE_ENGINE`` setting to
    setting yet.``                          something other than an empty string.
    ``Environment variable
    DJANGO_SETTINGS_MODULE is undefined.``  Run the command ``python manage.py shell``
                                            rather than ``python``.
    ``Error loading _____ module: No        You haven't installed the appropriate
    module named _____.``                   database-specific adapter (e.g.
                                            ``psycopg`` or ``MySQLdb``).
    ``_____ isn't an available database     Set your ``DATABASE_ENGINE`` setting to
    backend. Available backends are ...``   one of the valid engine settings described
                                            above. Perhaps you made a typo?
    ``database _____ does not exist``       Change the ``DATABASE_NAME`` setting to
                                            point to a database that exists, or
                                            execute the appropriate
                                            ``CREATE DATABASE`` statement in order to
                                            create it.
    ``role _____ does not exist``           Change ``DATABASE_USER`` setting to point
                                            to a user that exists, or create the user
                                            in your database.
    ``could not connect to server...``      Make sure ``DATABASE_HOST`` and
                                            ``DATABASE_PORT`` are set correctly.
    ======================================  ==========================================

Your first app
==============

Now that you've verified the connection is working, it's time to create a
**Django app** -- a bundle of Django code, including models and views, that
lives together in a single Python package and represents a full Django
application.

It's worth explaining the terminology here, because this tends to trip up
beginners. We'd already created a *project*, in Chapter 2, so what's the
difference between a *project* and an *app*? The difference is that of
configuration vs. code:

    * A project is an instance of a certain set of Django apps, plus the
      configuration for those apps.

      Technically, the only requirement of a project is that it supplies a
      settings file, which defines the database connection information, the
      list of installed apps, the ``TEMPLATE_DIRS``, etc.

    * An app is a portable set of Django functionality, usually including
      models and views, that lives together in a single Python package.

      For example, Django comes with a number of apps, such as a commenting
      system and an automatic admin interface. A key thing to note about these
      apps is that they're portable and reusable across multiple projects.

There are very few hard-and-fast rules about how you fit your Django code into
this scheme; it's flexible. If you're building a simple Web site, you may only
use a single app. If you're building a complex Web site with several seemingly
unrelated pieces such as an e-commerce system and a message board, you'll
probably want to split those into separate apps so that you'll be able to reuse
them individually.

Indeed, you don't necessarily have to create apps at all, as evidenced by the
example view functions we've created so far in this book. In those cases, we
simply created a file called ``views.py``, filled it with view functions and
pointed our URLconf at those functions. No "apps" were needed.

However, there's one requirement regarding the app convention: If you're using
Django's database layer (models), you must create a Django app. Models must
live within apps. Thus, in order to start writing our models, we'll need to
create a new app.

Within the ``mysite`` project directory you created in Chapter 2, type this
command to create a new app::

    python manage.py startapp books

(Why ``books``? That's the sample book app we'll be building together.)

This command does not result in any output, but it will have created a
``books`` directory within the ``mysite`` directory. Let's look at the contents
of that directory::

    books/
        __init__.py
        models.py
        views.py

These files will contain your models and views for this app.

Have a look at ``models.py`` and ``views.py`` in your favorite text editor.
Both files are empty, except for an import in ``models.py``. This is the blank
slate for your Django app.

Your first model
================

As we discussed above, the "M" in "MTV" stands for "Model." A Django model is a
description of the data in your database, represented as Python code. It's your
data layout -- the equivalent of your SQL ``CREATE TABLE`` statements -- except
it's in Python instead of SQL. Django uses it to execute SQL code behind the
scenes and return convenient Python data structures representing the rows in
your database tables.

If you're familiar with databases, your immediate thought might be, "Isn't it
redundant to define data models in Python *and* in SQL?"










it's redundant to define a
data layout in Python code

A drawback of this approach is that it's possible for the Python code to get out of sync with what's actually in the database.




Some other Web development platforms require that you define your models using
SQL rather than a high-level programming language such as Python. At first,
this philosophy makes sense: After all, the data is stored in a database, and a
database knows its own data layout, so why not define your models there first?
Wouldn't it be redundant to define data models in *both* Python *and* SQL?

While this logic makes sense on the surface, Django takes the opposite approach
for several reasons:

    * Introspection is expensive.

    * Writing SQL can be tough. Different databases require you to do things
      differently, and having to write three different versions of your
      data definitions is the opposite of elegant.

    * Having your data definitions stored in the database instead of in code
      means it's harder to keep your models under version control. Django does
      its best to support development best practices, which certainly includes
      the use of source control.

    * Your application will need to work with the database design regardless
      of how you created it. If you created it using SQL, you'd have to repeat
      yourself. Don't Repeat Yourself.

    * Writing Python is fun, and keeping everything in Python limits the number
      of times your brain has to do a "context switch."

    * Introspection is expensive.
















As an ongoing example in this chapter and the next chapter, we'll focus on a
basic book/author/publisher data model. We use this as our example because the
conceptual relationships between books, authors and publishers are well-known,
and this is a common data model used in introductory SQL textbooks.

We'll suppose these fields and relationships:

    * An author has a salutation (e.g., Mr. or Mrs.), a first name, a last
      name, an e-mail address and a headshot photo.

    * A publisher has a name, a street address, a city, a state/province, a
      country and a Web site.

    * A book has a title and a publication date. It also has one or more
      authors (a many-to-many relationship to author) and a single publisher
      (a one-to-many relationship, aka foreign key, to publisher).

The first step to use this database layout with Django is to express it as
Python code. In the ``models.py`` file that was created by the ``startapp``
command, type the following code::

    class Publisher(models.Model):
        name = models.CharField(maxlength=30)
        address = models.CharField(maxlength=50)
        city = models.CharField(maxlength=60)
        state_province = models.CharField(maxlength=30)
        country = models.CharField(maxlength=50)
        website = models.URLField()

    class Author(models.Model):
        salutation = models.CharField(maxlength=10)
        first_name = models.CharField(maxlength=30)
        last_name = models.CharField(maxlength=40)
        email = models.EmailField()
        headshot = models.ImageField()

    class Book(models.ModelField):
        title = models.CharField(maxlength=100)
        authors = models.ManyToManyField(Author)
        publisher = models.ForeignKey(Publisher)
        publication_date = models.DateField()














Run the following command to initialize your database with Django's default
installed apps::

    python manage.py syncdb

The ``syncdb`` command takes care of initalizing your database with any tables
not yet defined. You'll run it any time you add new models to your project;
see Chapter 3 for more information on the ``manage.py`` utility and the
``syncdb`` command.

If you're interested, run the command-line client for your database and type
``\dt`` (PostgreSQL), ``SHOW TABLES;`` (MySQL), or ``.schema`` (SQLite) to
display the tables Django created.

What's a model?
===============



Creating models
===============

Right, enough propaganda.  What does a model look like?

::

    from django.db import models

    class Crime(models.Model):
        when        = models.DateTimeField()
        location    = models.CharField(maxlength=300)
        description = models.TextField()

This describes a super-simple ``Crime`` model (which we'll expand over the
course of the next few chapters). Each ``Crime`` object has

    * a ``when`` field which is a date/time object
    * a ``location`` field which is a character field with a maximum length of
      300 characters,
    * and a ``description`` field which is a (unlimited length) text field.

Unless you instruct it otherwise (see XXX), Django will also automatically
create an integer primary key field called ``id``.

At this point, this is pretty much equivalent to the following SQL when using
PostgreSQL as the backend. ::

    CREATE TABLE "crimes_crime" (
        "id" serial NOT NULL PRIMARY KEY,
        "when" timestamp with time zone NOT NULL,
        "location" varchar(300) NOT NULL,
        "description" text NOT NULL
    );

In fact, we can generate that SQL above using Django itself.

Installing models
=================

First, though, we'll need to put this code into the place that Django expects
it to be. We'll put this code inside the first project you created in Chapter
2 (so go back and do that if you haven't already). You'll want to drop into a
shell, and in the project directory you created before, do::

    $ python manage.py startapp crimes

This will create a ``crimes`` package for you to put your code in. This
directory now contains two files, ``models.py`` and ``views.py``; you'll want
to put the model code above into the ``models.py`` file.

You've now created a model, but there's one more step to getting this model
registered with Django. In your ``settings.py`` file, you'll see a list called
``INSTALLED_APPS``. This list tells a given Django instance which apps should
be considered "active" for that instance. This lets you have a large library
of models and select which ones you want enabled on a site-by-site basis.
You'll want to modify ``INSTALLED_APPS`` so that it looks like::

    INSTALLED_APPS = (
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.sites',
        'mysite.crimes',         # <-- add this line
    )

Now your app is registered with this Django project. The first thing you'll
want to do to celebrate is to make sure you've got the model defined
correctly. Try this::

    $ python manage.py validate

Django should spit out ``0 errors found``; if it doesn't, it means you've got
errors defined in your model somewhere. Check that you've copied the code
above correctly.

From here, you'll probably want to install this model into you database so you
can start reading and writing data from and to the database. Run::

    $ python manage.py syncdb

This automatically creates the tables for this model in the database. You'll
re-run ``syncdb`` every time you add new models to your project so that Django
creates the related tables in the database.

If you want to see the SQL that Django is running against your database, you
can run::

    $ python manage.py sql crimes

to have Django print the SQL for the ``crimes`` model to the console (with
pretty syntax highlighting on \*nix). There's also quite a number of other
things you can do with ``manage.py``; see Chapter XXX for a complete
reference.

.. XXX JGD This command shows nothing after running syncdb.  It should be noted that the output changes depending on whether your DB's already been synced for a given installed app.

Playing with the Python API
===========================

Once you've created a model, Django automatically provides a high-level Python
API for working with those models. Let's try it out -- try the following::

    $ python manage.py shell

    >>> from crimes.models import Crime
    >>> from datetime import datetime

    >>> c = Crime(when=datetime.now(), location="1137 Vermont St",
    ...           description="Breaking and Entering")
    ...
    >>> c.save()

    >>> c2 = Crime(when=datetime.now(), location="1208 Florida St",
    ...           description="Reckless driving")
    ...
    >>> c2.save()

    >>> crime_list = Crime.objects.all()
    >>> print crime_list
    [<Crime: Crime object>, <Crime: Crime object>]


Although it's only a few lines of code, this actually does quite a bit. You
can see how objects are created (Django objects are simply Python classes) and
saved to the database (all Django objects have a ``save()`` method which saves
the object to the database).

You can also see how objects are retrieved from the database:
``Crime.objects`` lets you interact with the objects already stored in the
database. ``Crime.objects.all()`` is how you fetch a list of already-created
``Crime`` objects from the database.

..note::

    ``Crime.objects`` is a "manager" object; see Chapter XXX for more
    information about managers.

There's quite a lot more you can do here -- and in fact Chapter XXX has a
complete reference to this object API -- but first let's take care of a small
annoyance.

As you can see above, when we printed out the list of crimes, all we got was
the unhelpful::

    [<Crime: Crime object>, <Crime: Crime object>]

We can fix that easily by adding a method to our ``Crime`` object that handles
conversion to a string. This takes the shape of a Python "magic method" called
``__str__``; you can see it in action by adding one to your ``Crime`` class::

    class Crime(models.Model):
        when        = models.DateTimeField()
        location    = models.CharField(maxlength=300)
        description = models.TextField()

        def __str__(self):
            return "Crime at %s on %s" % \
                (self.location, self.when.strftime("%Y-%m-%d"))

Now, printing the list of crimes looks a lot better::

    >>> Crime.objects.all()
    [<Crime: Crime at 1137 Vermont St on 2006-05-16>,
     <Crime: Crime at 1208 Florida St on 2006-05-16>]

.. XXX JGD Seeing this change requires reloading the Crime model, no?  Maybe explain that or
.. XXX JGD show it by doing from crimes import models and referring to models.Crime,
.. XXX JGD so you can reload(models).  Or am I being stupid?

You'll want to make sure that any model you define has the ``__str__`` method.
Django uses this method anywhere a human-readable version of the object needs
to be displayed.

.. XXX JGD A note explaining that user-facing pages generally won't be relying on __str__
.. XXX JGD would be good.  __str__ is mostly helpful terminal and admin, right?  Or, put
.. XXX JGD  another way, if too much relies on __str__, when __str__ needs to change for
.. XXX JGD   some need, all places relying on __str__ will need to change.  This is the
.. XXX JGD    same reason surrogate keys (aka id sequence) are used in DBs even if a natural
.. XXX JGD     key exists.

Customizing object metadata
===========================

To save you time, Django automatically derives the name of the database table
from the name of your model class and the app that contains it. A model's
database table name is constructed by joining the model's "app label" -- the
name you used in ``manage.py startapp`` -- to the model's class name, with an
underscore between them.

So, if you examine your database now (or the output of ``manage.py sql
crimes``) you'll see that Django has automatically named the ``Crime`` table
``crimes_crime``.

So what if you're sharing a database with other users and you need to be
careful about table names, or what if you just don't like the automatic name?
Well, each Django model can define metadata about that object; this is done by
defining an inner class called ``Meta``::

    class Crime(models.Model):
        when        = models.DateTimeField()
        location    = models.CharField(maxlength=300)
        description = models.TextField()

        class Meta:
            db_table = "crimes"

The ``db_table`` option overrides the default table name that Django uses.
There's really no reason to use this option now, so for the rest of this
walkthrough we'll assume you removed it.

.. admonition:: Philosophy

    You'll see this pattern repeated everywhere in Django.  The framework
    provides sensible defaults, but always lets you override them if you
    need more fine-grained control.

.. XXX JGD No nod/snark to "convention over configuration"?

Of course, there are other ``Meta`` options available; refer to Chapter XXX
for a complete reference.

Relations
=========

Of course, what's the point of using a relational database if we don't use
relations? Let's refine our ``Crime`` object to be somewhat better designed.
Right now, we're simply stuffing a description of the crime into the
``description`` field, but that will quickly fill up with duplicate values
like "carjacking" and "distributing cigarettes to minors". Let's break those
crime types out into a related object::

    class CrimeType(models.Model):
        name        = models.CharField(maxlength=250)
        is_felony   = models.BooleanField()

        def __str__(self):
            return self.name

.. XXX JGD This has to be in the models.py file before Crime, right?  It'd be good to note it.

Here we've defined a "crime type" object which we'll populate with all the
possible crimes on the books. Now we'll modify the exiting ``Crime`` object to
replace the ``description`` field with a relation to this one::

    class Crime(models.Model):
        when        = models.DateTimeField()
        location    = models.CharField(maxlength=300)
        type        = models.ForeignKey(CrimeType)

.. XXX JGD You're both modifying an existing bit of code and excluding
.. XXX JGD some previously-added code.  It'd be good to make it clear that the other
.. XXX JGD code is not to be removed.  Perhaps a small
.. XXX JGD admonition at the first occurrence of this in the book?

This defines a foreign key on the ``type`` field which points to a ``CrimeType``.

.. admonition:: Huh?

    What's a "foreign key"?  If you're not familiar with database terminology,
    XXX what should they do??? XXX

.. XXX JGD We could just have a glossary for the book (which could include any DB terms
.. XXX JGD you don't want to assume).  Or, if it's not too political, you could recommend
.. XXX JGD a couple books (one for each popular backend?).
.. XXX JGD Lastly, Wikipedia has nice relation data modeling coverage:
.. XXX JGD http://en.wikipedia.org/wiki/Category:Data_modeling

Modifying models
================

If you actually try to use these models at this point, you'll quickly find
problems. Although you've changed the ``Crime`` model, those changes can't
automatically be transfered into the database. You've got to inform the
database that you've changed the model, and you've got two options::

    1. Use SQL to modify the database tables.  That is, use ``ALTER TABLE``
       commands to modify the database directly to match the model.

       This is the approach you have to take if you've already got important
       data stored in the database.

    2. If, however, you don't care about the data in the database, you can
       "reset" a given model, dropping and restoring the tables involved.

Since we've just started, we'll take the second route.  Run::

    $ python manage.py reset crimes

Django will ask you if you're *sure* that this is something you want to do;
say "yes" and the old tables will be dropped and new ones created.

.. admonition:: Philosophy:

    Yes, you're right to think that option 1 looks pretty difficult.  If
    you've got to make a schema change in an application with a bunch of
    existing data it can indeed be time-consuming.

    However, automated tools could be very dangerous here. Django won't
    automatically modify your database for you; that could lead to
    catastrophic data loss.

    So, spend a little extra time up front making sure your models are
    well-defined and future-proof.  You'll recover that time in spades
    in the future -- trust us!

.. XXX JGD It's impossible to future-proof, and its wrong to suggest it is possible.
.. XXX JGD As a newcomer to Django, this looks suspiciously like the Python-defined
.. XXX JGD models is necessary but not sufficient for the DRY principle.
.. XXX JGD Migration code obviously shouldn't be automated.
.. XXX JGD What's up with http://code.djangoproject.com/wiki/SchemaEvolution#conclusions ?
.. XXX JGD Assuming that won't be done, the book should at least go through one
.. XXX JGD real-worldy model design update process.
.. XXX JGD Another thing that would help is to explain the thought process involved in
.. XXX JGD future-proofing (with your crystal ball).
.. XXX JGD I'm not tryin' to be a jerk, but you can't pretend it's not an issue.  :)

Using relations in the Python API
=================================

Now that we've got CrimeType defined in the database, we'll set up a few
example Crimes using the new ``CrimeType`` to explore the Django API for
foreign keys.  Back to the shell::

    $ python manage.py shell
    >>> from crimes.models import Crime, CrimeType
    >>> from datetime import datetime
    >>> jaywalking = CrimeType(name="Jaywakling", is_felony=False)
    >>> jaywalking.save()
    >>> florida_jaywalking = Crime(when=datetime.now(),
    ...                            location="1211 Florida St", type=jaywalking)
    >>> florida_jaywalking.save()
    >>> fortysecond_jaywalking = Crime(when=datetime.now(),
    ...                            location="1301 W. 42nd St", type=jaywalking)
    >>> fortysecond_jaywalking.save()

Now you can retrieve all Crimes of the same CrimeType for any given Crime::

    >>> fortysecond_jaywalking.type.crime_set.all()
    [<Crime: Crime at 1211 Florida St on 2006-05-17>, <Crime: Crime at 1301 W. 42nd St on 2006-05-17>]

Those Crimes refer to the same CrimeType object so that changes in the
CrimeType are reflected in all Crimes::

    >>> jaywalking.crime_set.all()[0].type
    <CrimeType: Jaywakling>
    >>> jaywalking.name="Jaywalking"
    >>> jaywalking.save()
    >>> jaywalking.crime_set.all()[0].type
    <CrimeType: Jaywalking>
    >>> jaywalking.crime_set.all()[1].type
    <CrimeType: Jaywalking>

XXX explain interesting code here

.. XXX: talk about M2M next, or leave that for the ref?

.. XXX JGD Is there an M2M in chicrime that's not too out of the way?

.. XXX JGD Also, I think it'd be good to talk about model cycles.
.. XXX JGD A Person is holding an Event which has a list of Invitees.
.. XXX JGD This may be a pet issue since I ran into it w/ MediaWiki's existing schema.

What's next?
============

At this point you know enough (with the help of the reference in Chapter XXX)
to start writing your own models. However, in the next chapter we'll step
aside to look at the best-looking piece of Django: the automatic admin
interface.
