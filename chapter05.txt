==============================================
Chapter 5: Interacting with a database: Models
==============================================

In Chapter 3, we covered the fundamentals of building dynamic Web sites
with Django: setting up views and URLconfs. As we explained, a view is
responsible for doing *some arbitrary logic*, then returning a response. In the
example, our *arbitrary logic* was to calculate the current date and time.

In many modern Web applications, the *arbitrary logic* involves interacting
with a database. Behind the scenes, a so-called **database-driven Web site**
connects to a database server, retrieves some data out of it and displays that
data, nicely formatted, on a Web page. Or, similarly, the site could provide
HTML forms that let site visitors populate the database on their own.

Many complex Web sites provide some combination of the two. Amazon.com, for
instance, is a great example of a database-driven site. Each product page is
essentially an HTML view into Amazon's product database, and when you post a
customer review, it gets inserted into the database of reviews.

Django is very well-suited for making database-driven Web sites, as it comes
with easy yet powerful ways of performing database queries with Python. This
chapter explains that functionality -- Django's database layer.

(Note: We'll assume you are familiar with basic database theory and SQL. An
introduction to those concepts is out of the scope of this book.)

The MTV development pattern
===========================

Before we delve into code, let's a moment to consider the overall design of a
database-driven Django Web application.

Your first app
==============

Database setup
==============

Now, edit ``settings.py``. It's a normal Python module with module-level
variables representing Django settings. Change these settings to match your
database's connection parameters:

    ``DATABASE_ENGINE``
        Either 'postgresql', 'mysql', 'sqlite3', `ado_mssql`, or `oracle`. See
        `Setting up a database` for more information about each database
        Django supports.

    ``DATABASE_NAME``
        The name of your database, or the full (absolute) path to the database
        file if you're using SQLite.

    ``DATABASE_USER``
        Your database username (not used for SQLite).

    ``DATABASE_PASSWORD``
        Your database password (not used for SQLite).

    ``DATABASE_HOST``
        The host your database is on. Leave this as an empty string if your
        database server is on the same physical machine (not used for SQLite).

.. note::

    Make sure you've created a database within your database application by
    this point. Do that with "``CREATE DATABASE database_name;``" within your
    database's interactive prompt (such as ``psql`` or ``mysql``).

Run the following command to initialize your database with Django's default
installed apps::

    python manage.py syncdb

The ``syncdb`` command takes care of initalizing your database with any tables
not yet defined. You'll run it any time you add new models to your project;
see Chapter 3 for more information on the ``manage.py`` utility and the
``syncdb`` command.

If you're interested, run the command-line client for your database and type
``\dt`` (PostgreSQL), ``SHOW TABLES;`` (MySQL), or ``.schema`` (SQLite) to
display the tables Django created.

What's a model?
===============

In a nutshell, a model describes your data. They're like a blueprint: they
explain what types of objects you'll use, what fields those objects have, and
how it all fits together. In Django, models definitions also contain metadata
about your models that Django uses to build APIs -- more on that later.

In Django, you define these models as Python modules and then use tools to
turn those models into SQL data definitions that create tables in your
database.

Now, many web development platforms want you to define your models using SQL.
After all, the data will eventually be stored in a database, so why not simply
define your models there first? While this logic makes sense on the surface,
we disagree:

    * Writing SQL can be tough.  Different databases require you to do things
      differently, and having to write three different versions of your
      data definitions is the opposite of elegant.

    * Having your data definitions stored in the database instead of in code
      means it's harder to keep your models under version control. Django does
      its best to support development best practices, which certainly includes
      the use of source control.

    * Your application will need to work with the database design regardless
      of how you created it. If you created it using SQL, you'd have to repeat
      yourself. Don't Repeat Yourself.

    * Writing Python is fun! Django does its best to keep you writing Python
      all the time.

.. XXX JGD Added a fourth reason.

Creating models
===============

Right, enough propaganda.  What does a model look like?

::

    from django.db import models

    class Crime(models.Model):
        when        = models.DateTimeField()
        location    = models.CharField(maxlength=300)
        description = models.TextField()

This describes a super-simple ``Crime`` model (which we'll expand over the
course of the next few chapters). Each ``Crime`` object has

    * a ``when`` field which is a date/time object
    * a ``location`` field which is a character field with a maximum length of
      300 characters,
    * and a ``description`` field which is a (unlimited length) text field.

Unless you instruct it otherwise (see XXX), Django will also automatically
create an integer primary key field called ``id``.

At this point, this is pretty much equivalent to the following SQL when using
PostgreSQL as the backend. ::

    CREATE TABLE "crimes_crime" (
        "id" serial NOT NULL PRIMARY KEY,
        "when" timestamp with time zone NOT NULL,
        "location" varchar(300) NOT NULL,
        "description" text NOT NULL
    );

In fact, we can generate that SQL above using Django itself.

Installing models
=================

First, though, we'll need to put this code into the place that Django expects
it to be. We'll put this code inside the first project you created in Chapter
2 (so go back and do that if you haven't already). You'll want to drop into a
shell, and in the project directory you created before, do::

    $ python manage.py startapp crimes

This will create a ``crimes`` package for you to put your code in. This
directory now contains two files, ``models.py`` and ``views.py``; you'll want
to put the model code above into the ``models.py`` file.

You've now created a model, but there's one more step to getting this model
registered with Django. In your ``settings.py`` file, you'll see a list called
``INSTALLED_APPS``. This list tells a given Django instance which apps should
be considered "active" for that instance. This lets you have a large library
of models and select which ones you want enabled on a site-by-site basis.
You'll want to modify ``INSTALLED_APPS`` so that it looks like::

    INSTALLED_APPS = (
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.sites',
        'mysite.crimes',         # <-- add this line
    )

Now your app is registered with this Django project. The first thing you'll
want to do to celebrate is to make sure you've got the model defined
correctly. Try this::

    $ python manage.py validate

Django should spit out ``0 errors found``; if it doesn't, it means you've got
errors defined in your model somewhere. Check that you've copied the code
above correctly.

From here, you'll probably want to install this model into you database so you
can start reading and writing data from and to the database. Run::

    $ python manage.py syncdb

This automatically creates the tables for this model in the database. You'll
re-run ``syncdb`` every time you add new models to your project so that Django
creates the related tables in the database.

If you want to see the SQL that Django is running against your database, you
can run::

    $ python manage.py sql crimes

to have Django print the SQL for the ``crimes`` model to the console (with
pretty syntax highlighting on \*nix). There's also quite a number of other
things you can do with ``manage.py``; see Chapter XXX for a complete
reference.

.. XXX JGD This command shows nothing after running syncdb.  It should be noted that the output changes depending on whether your DB's already been synced for a given installed app.

Playing with the Python API
===========================

Once you've created a model, Django automatically provides a high-level Python
API for working with those models. Let's try it out -- try the following::

    $ python manage.py shell

    >>> from crimes.models import Crime
    >>> from datetime import datetime

    >>> c = Crime(when=datetime.now(), location="1137 Vermont St",
    ...           description="Breaking and Entering")
    ...
    >>> c.save()

    >>> c2 = Crime(when=datetime.now(), location="1208 Florida St",
    ...           description="Reckless driving")
    ...
    >>> c2.save()

    >>> crime_list = Crime.objects.all()
    >>> print crime_list
    [<Crime: Crime object>, <Crime: Crime object>]


Although it's only a few lines of code, this actually does quite a bit. You
can see how objects are created (Django objects are simply Python classes) and
saved to the database (all Django objects have a ``save()`` method which saves
the object to the database).

You can also see how objects are retrieved from the database:
``Crime.objects`` lets you interact with the objects already stored in the
database. ``Crime.objects.all()`` is how you fetch a list of already-created
``Crime`` objects from the database.

..note::

    ``Crime.objects`` is a "manager" object; see Chapter XXX for more 
    information about managers.

There's quite a lot more you can do here -- and in fact Chapter XXX has a
complete reference to this object API -- but first let's take care of a small
annoyance.

As you can see above, when we printed out the list of crimes, all we got was
the unhelpful::

    [<Crime: Crime object>, <Crime: Crime object>]

We can fix that easily by adding a method to our ``Crime`` object that handles
conversion to a string. This takes the shape of a Python "magic method" called
``__str__``; you can see it in action by adding one to your ``Crime`` class::

    class Crime(models.Model):
        when        = models.DateTimeField()
        location    = models.CharField(maxlength=300)
        description = models.TextField()

        def __str__(self):
            return "Crime at %s on %s" % \
                (self.location, self.when.strftime("%Y-%m-%d"))

Now, printing the list of crimes looks a lot better::

    >>> Crime.objects.all()
    [<Crime: Crime at 1137 Vermont St on 2006-05-16>,
     <Crime: Crime at 1208 Florida St on 2006-05-16>]

.. XXX JGD Seeing this change requires reloading the Crime model, no?  Maybe explain that or
.. XXX JGD show it by doing from crimes import models and referring to models.Crime,
.. XXX JGD so you can reload(models).  Or am I being stupid?

You'll want to make sure that any model you define has the ``__str__`` method.
Django uses this method anywhere a human-readable version of the object needs
to be displayed.

.. XXX JGD A note explaining that user-facing pages generally won't be relying on __str__
.. XXX JGD would be good.  __str__ is mostly helpful terminal and admin, right?  Or, put
.. XXX JGD  another way, if too much relies on __str__, when __str__ needs to change for
.. XXX JGD   some need, all places relying on __str__ will need to change.  This is the
.. XXX JGD    same reason surrogate keys (aka id sequence) are used in DBs even if a natural
.. XXX JGD     key exists.

Customizing object metadata
===========================

To save you time, Django automatically derives the name of the database table
from the name of your model class and the app that contains it. A model's
database table name is constructed by joining the model's "app label" -- the
name you used in ``manage.py startapp`` -- to the model's class name, with an
underscore between them.

So, if you examine your database now (or the output of ``manage.py sql
crimes``) you'll see that Django has automatically named the ``Crime`` table
``crimes_crime``.

So what if you're sharing a database with other users and you need to be
careful about table names, or what if you just don't like the automatic name?
Well, each Django model can define metadata about that object; this is done by
defining an inner class called ``Meta``::

    class Crime(models.Model):
        when        = models.DateTimeField()
        location    = models.CharField(maxlength=300)
        description = models.TextField()

        class Meta:
            db_table = "crimes"

The ``db_table`` option overrides the default table name that Django uses.
There's really no reason to use this option now, so for the rest of this
walkthrough we'll assume you removed it.

.. admonition:: Philosophy

    You'll see this pattern repeated everywhere in Django.  The framework
    provides sensible defaults, but always lets you override them if you
    need more fine-grained control.

.. XXX JGD No nod/snark to "convention over configuration"?

Of course, there are other ``Meta`` options available; refer to Chapter XXX
for a complete reference.

Relations
=========

Of course, what's the point of using a relational database if we don't use
relations? Let's refine our ``Crime`` object to be somewhat better designed.
Right now, we're simply stuffing a description of the crime into the
``description`` field, but that will quickly fill up with duplicate values
like "carjacking" and "distributing cigarettes to minors". Let's break those
crime types out into a related object::

    class CrimeType(models.Model):
        name        = models.CharField(maxlength=250)
        is_felony   = models.BooleanField()

        def __str__(self):
            return self.name

.. XXX JGD This has to be in the models.py file before Crime, right?  It'd be good to note it.

Here we've defined a "crime type" object which we'll populate with all the
possible crimes on the books. Now we'll modify the exiting ``Crime`` object to
replace the ``description`` field with a relation to this one::

    class Crime(models.Model):
        when        = models.DateTimeField()
        location    = models.CharField(maxlength=300)
        type        = models.ForeignKey(CrimeType)

.. XXX JGD You're both modifying an existing bit of code and excluding
.. XXX JGD some previously-added code.  It'd be good to make it clear that the other
.. XXX JGD code is not to be removed.  Perhaps a small
.. XXX JGD admonition at the first occurrence of this in the book?

This defines a foreign key on the ``type`` field which points to a ``CrimeType``.

.. admonition:: Huh?

    What's a "foreign key"?  If you're not familiar with database terminology,
    XXX what should they do??? XXX

.. XXX JGD We could just have a glossary for the book (which could include any DB terms
.. XXX JGD you don't want to assume).  Or, if it's not too political, you could recommend
.. XXX JGD a couple books (one for each popular backend?).
.. XXX JGD Lastly, Wikipedia has nice relation data modeling coverage:
.. XXX JGD http://en.wikipedia.org/wiki/Category:Data_modeling

Modifying models
================

If you actually try to use these models at this point, you'll quickly find
problems. Although you've changed the ``Crime`` model, those changes can't
automatically be transfered into the database. You've got to inform the
database that you've changed the model, and you've got two options::

    1. Use SQL to modify the database tables.  That is, use ``ALTER TABLE``
       commands to modify the database directly to match the model.

       This is the approach you have to take if you've already got important
       data stored in the database.

    2. If, however, you don't care about the data in the database, you can
       "reset" a given model, dropping and restoring the tables involved.

Since we've just started, we'll take the second route.  Run::

    $ python manage.py reset crimes

Django will ask you if you're *sure* that this is something you want to do;
say "yes" and the old tables will be dropped and new ones created.

.. admonition:: Philosophy:

    Yes, you're right to think that option 1 looks pretty difficult.  If
    you've got to make a schema change in an application with a bunch of
    existing data it can indeed be time-consuming.

    However, automated tools could be very dangerous here. Django won't
    automatically modify your database for you; that could lead to
    catastrophic data loss.

    So, spend a little extra time up front making sure your models are
    well-defined and future-proof.  You'll recover that time in spades
    in the future -- trust us!

.. XXX JGD It's impossible to future-proof, and its wrong to suggest it is possible.
.. XXX JGD As a newcomer to Django, this looks suspiciously like the Python-defined
.. XXX JGD models is necessary but not sufficient for the DRY principle.
.. XXX JGD Migration code obviously shouldn't be automated.
.. XXX JGD What's up with http://code.djangoproject.com/wiki/SchemaEvolution#conclusions ?
.. XXX JGD Assuming that won't be done, the book should at least go through one
.. XXX JGD real-worldy model design update process.
.. XXX JGD Another thing that would help is to explain the thought process involved in
.. XXX JGD future-proofing (with your crystal ball).
.. XXX JGD I'm not tryin' to be a jerk, but you can't pretend it's not an issue.  :)

Using relations in the Python API
=================================

Now that we've got CrimeType defined in the database, we'll set up a few 
example Crimes using the new ``CrimeType`` to explore the Django API for 
foreign keys.  Back to the shell::

    $ python manage.py shell
    >>> from crimes.models import Crime, CrimeType
    >>> from datetime import datetime
    >>> jaywalking = CrimeType(name="Jaywakling", is_felony=False)
    >>> jaywalking.save()
    >>> florida_jaywalking = Crime(when=datetime.now(), 
    ...                            location="1211 Florida St", type=jaywalking)
    >>> florida_jaywalking.save()
    >>> fortysecond_jaywalking = Crime(when=datetime.now(), 
    ...                            location="1301 W. 42nd St", type=jaywalking)
    >>> fortysecond_jaywalking.save()

Now you can retrieve all Crimes of the same CrimeType for any given Crime::

    >>> fortysecond_jaywalking.type.crime_set.all()
    [<Crime: Crime at 1211 Florida St on 2006-05-17>, <Crime: Crime at 1301 W. 42nd St on 2006-05-17>]

Those Crimes refer to the same CrimeType object so that changes in the
CrimeType are reflected in all Crimes::

    >>> jaywalking.crime_set.all()[0].type
    <CrimeType: Jaywakling>
    >>> jaywalking.name="Jaywalking"
    >>> jaywalking.save()
    >>> jaywalking.crime_set.all()[0].type
    <CrimeType: Jaywalking>
    >>> jaywalking.crime_set.all()[1].type
    <CrimeType: Jaywalking>

XXX explain interesting code here

.. XXX: talk about M2M next, or leave that for the ref?

.. XXX JGD Is there an M2M in chicrime that's not too out of the way?

.. XXX JGD Also, I think it'd be good to talk about model cycles.
.. XXX JGD A Person is holding an Event which has a list of Invitees.
.. XXX JGD This may be a pet issue since I ran into it w/ MediaWiki's existing schema.

What's next?
============

At this point you know enough (with the help of the reference in Chapter XXX)
to start writing your own models. However, in the next chapter we'll step
aside to look at the best-looking piece of Django: the automatic admin
interface.

So what are you waiting for? Turn the page!

