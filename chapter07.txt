==========================
Chapter 7: Form processing
==========================

If you did your "homework" from last chapter, you should now have a fully
functioning if somewhat simple site. In this chapter, we'll deal with the last
piece of the puzzle: building views that take input from readers.

We'll start by making a simple search form "by hand" and looking at how to
handle data submitted from the browser, and move from there to using Django's
form and "manipulator" frameworks.

Search
======

The web is all about search. Two of the 'net's biggest success stories --
Google and Yahoo -- built their multi-billion dollar businesses around search.
Nearly every site sees a large percentage of traffic coming to and from its
search pages. Often the difference between the success or failure of a site is
the quality of its search.

So it looks like we'd better add some searching to our fledgling crime site,
no?

We'll start with by adding the search view to our URLconf
(``mysite.crimes.urls``). Recall that this means adding something like ``
(r'^search/$', 'search')`` to the set of URL patterns.

Next, we'll write this ``search`` view into our view module
(``mysite.crimes.views``)::

    from django.db.models import Q

    def search(request):
        query = request.GET.get('q', '')
        if query:
            qset = Q(location__icontains=query) | Q(type__name__icontains=query)
            results = Crime.objects.filter(qset)
        else:
            results = []
        return render_to_response("crimes/search.html", {
            "results": results,
            "query": q
        })

There's a couple of things going on here you've not seen yet.

First, there's this ``request.GET`` business. This is how you access GET data
from Django; POST data is accessed through a similar ``request.POST`` object.
These objects behave exactly like standard Python dictionaries with some extra
features covered in Appendix H.

.. admonition:: What's GET and POST data?

    GET and POST are the two methods that browsers use to send data to a
    server. Most of the time, you'll see them in HTML form tags::

        <form action="/crimes/search/" method="GET">

    This instructs the browser to submit the form data to the URL
    ``/crimes/search/`` using the GET method.

    There are important differences between the semantics of GET and POST that
    we won't get into right now, but see XXX SOME REFERENCE XXX if you want
    to know more.

So the line::

    query = request.GET.get('q', '')

looks for a GET parameter named ``q`` and returns an empty string if that
parameter wasn't submitted.

Second, what about this ``Q`` business? ``Q`` objects are used to build up
complex queries -- in this case, we're searching for any crimes with a
location that matches the query or a type that matches. This lets someone
search for either a street name or a crime type and "does the right thing" in
each circumstance.

Technically, these ``Q`` objects comprise a **QuerySet**, and you can read
more about them in Appendix C.

There's still no template for this search view, however. This should do the
trick::

    {% extends "base.html" %}

    {% block title %}
      Search {% if query %}Results{% endif %}
    {% endblock %}

    {% block content %}
      <form action="." method="GET">
        <label for="q">Search: </label>
        <input type="text" name="q" value="{{ query|escape }}">
      </form>

      {% if query %}
        <h2>Results for "{{ query|escape }}":</h2>

        {% if results %}
          <ul>
          {% for crime in results %}
            <li>{{ crime }}</l1>
          {% endfor %}
          </ul>
        {% else %}
          <p>No crimes found</p>
        {% endif %}
      {% endif %}
    {% endblock %}

Hopefully by now what this does is fairly obvious. However, there are a few
subtleties worth pointing out::

    * The form's action is ``.``, which means "the current URL".  This is a
      standard best practice: don't have separate views for the form page and
      the result page; use a single one which serves the form and possibly the
      results if they've been searched for.

    * We reinsert the value of the query back into the ``<input>``.  This lets
      readers easily refine their searches without having to retype what they
      searched for.

    * Every place ``query`` is used, we pass it through the ``escape`` filter
      to make sure that any potentially malicious search text is filtered out
      before being inserted into the page.

      It's **vital** that you do this with any user-submitted content!
      Otherwise you open your site up to cross-site scripting (XSS) attacks.

    * However, we don't need to worry about harmful content in your database
      lookups, we can simply pass the query into the lookup as-is.  This is
      because Django's database layer handles this aspect of security for you.

Now we've got working search. A further improvement would be putting a search
form on every page (i.e. in the base template); we'll let you handle that one
yourself.

User-submitted content
======================

Search is great all, but what about letting users submit crimes themselves?
After all, the great innovation of the so-called "Web 2.0" movement is the
realization of the read-write Web.

.. admonition:: Dear O'Reilly:

    Please don't sue us. we mean the "other" Web 2.0, not the one you
    trademarked.

So why not build a form that lets readers submit their own data? Since this is
just a tutorial, we'll pretend there aren't any problems with this idea and
forge ahead with a submission view.

To do that, we'll need to dive into the wild and wooly world of
manipulators...

.. admonition:: A note to the lazy

    If all you want to do is present forms for a user to create and/or
    update a given object, you can probably use generic views (see
    Chapter 8).  As with the last chapter, this information is here
    so that you can understand how this stuff works before moving onto
    more complex topics.

Manipulators
============

.. The content from here on down comes from Django's forms.txt doc

The highest-level interface for object creation and modification is the
**Manipulator** framework. A manipulator is a utility class tied to a given
model that "knows" how to create or modify instances of that model and how to
validate data for the object.

Manipulators come in two flavors: ``AddManipulators`` and
``ChangeManipulators``. Functionally they are quite similar, but the former
knows how to create new instances of the model, while the later modifies
existing instances. Both types of classes are automatically created when you
define a new class::

    >>> from mysite.crrimes.models import Crime
    >>> Crime.AddManipulator
    <class 'django.models.manipulators.AddManipulator'>
    >>> Crime.ChangeManipulator
    <class 'django.models.manipulators.ChangeManipulator'>

Using the ``AddManipulator``
----------------------------

We'll start with the ``AddManipulator``.  Here's a very simple view that takes
POSTed data from the browser and creates a new ``Crime`` object::

    from django import forms
    from django.http import HttpResponse
    from django.shortcuts import render_to_response
    from mysite.crrimes.models import Crime

    def naive_create_crime(request):
        """
        A naive approach to creating crimes; don't actually use this!
        """

        # Create the AddManipulator.
        manipulator = Crime.AddManipulator()

        # Make a copy of the POSTed data so that do_html2python can
        # modify it in place (request.POST is immutable).
        new_data = request.POST.copy()

        # Convert the request data (which will all be strings) into the
        # appropriate Python types for those fields.
        manipulator.do_html2python(new_data)

        # Save the new object.
        new_crime = manipulator.save(new_data)

        # It worked!
        return HttpResponse("Crime created: %s" % new_crime)

The ``naive_create_crime`` example works, but as you probably can tell, this
view has a number of problems:

    * No validation of any sort is performed. If, for example, the ``name``
      field isn't given in ``request.POST``, the save step will cause a
      database error because that field is required. Ugly.

    * Even if you *do* perform validation, there's still no way to give that
      information to the user in any sort of useful way.

    * You'll have to separately create a form (and view) that submits to this
      page, which is a pain and is redundant.

Let's dodge these problems momentarily to take a look at how you could create
a view with a form that submits to this flawed creation view::

    def naive_create_crime_form(request):
        """
        Simplistic place form view; don't actually use anything like this!
        """

        # Create a FormWrapper object that the template can use. Ignore
        # the last two arguments to FormWrapper for now.
        form = forms.FormWrapper(Crime.AddManipulator(), {}, {})
        return render_to_response('crimes/naive_create_form.html', {
            'form': form}
        )

(This view, as well as all the following ones, has the same imports as in the
first example above.)

The ``forms.FormWrapper`` object is a wrapper that templates can easily deal
with to create forms. Here's the ``naive_create_form.html`` template::

    {% extends "base.html" %}

    {% block content %}
    <h1>Create a crime:</h1>

    <form method="post" action="../do_new/">
    <p><label for="id_type">Type:</label> {{ form.type }}</p>
    <p><label for="id_location">Address:</label> {{ form.location }}</p>
    <p><label for="id_when_date">Crime date:</label> {{ form.when_date }}</p>
    <p><label for="id_when_time">Crime time:</label> {{ form.when_time }}</p>
    <input type="submit" />
    </form>
    {% endblock %}

Before we get back to the problems with these naive set of views, let's go
over some salient points of the above template::

    * Field "widgets" are handled for you: ``{{ form.field }}`` automatically
      creates the "right" type of widget for the form, as you can see with the
      ``place_type`` field above.

    * Django automatically notices that the ``type`` field is a relation, and
      uses a ``<select>`` form with all the available crime types.

    * DateTime widgets use two fields -- ``field_date`` and ``field_time``.

    * There isn't a way just to spit out the form. You'll still need to define
      how the form gets laid out.

      *This is a feature*; Every form should be designed differently. Django
      doesn't force you into any type of mold. If you must use tables, use
      tables. If you're a semantic purist, you can probably find better HTML
      than in the above template.

    * To avoid name conflicts, the ``id``s of form elements take the form
      "id_*fieldname*".

By creating a creation form we've solved problem number 3 above, but we still
don't have any validation. Let's revisit the validation issue by writing a new
creation view that takes validation into account::

    def create_crime_with_validation(request):
        manipulator = Crime.AddManipulator()
        new_data = request.POST.copy()

        # Check for validation errors
        errors = manipulator.get_validation_errors(new_data)
        if errors:
            return render_to_response('places/errors.html', {
                'errors': errors
            })
        else:
            manipulator.do_html2python(new_data)
            new_crime = manipulator.save(new_data)
            return HttpResponse("Crime created: %s" % new_crime)

In this new version, errors will be found --
``manipulator.get_validation_errors`` handles all the validation for you --
and those errors can be nicely presented on an error page (templated, of
course)::

    {% extends "base.html" %}

    {% block content %}
    <h1>Please go back and correct your error{{ errors|pluralize }}:</h1>
    <ul>
        {% for e in errors.items %}
        <li>Field "{{ e.0 }}": {{ e.1|join:", " }}</li>
        {% endfor %}
    </ul>
    {% endblock %}

This still has problems:

    * There's still the issue of creating a separate (redundant) view for the
      submission form.

    * Errors, though nicely presented, are on a separate page, so the user
      will have to use the "back" button to fix errors. That's so unusable
      it's ridiculous..

The best way to deal with these issues is to collapse the two views -- the
form and the submission -- into a single view. This view will be responsible
for creating the form, validating POSTed data, and creating the new object (if
the data is valid). An added bonus of this approach is that errors and the
form will both be available on the same page, so errors with fields can be
presented in context.

.. admonition:: Philosophy:

    Finally, for the HTTP purists in the audience (and authorship), this
    nicely matches the "true" meanings of HTTP GET and HTTP POST: GET fetches
    the form, and POST creates the new object.

Here's the collapsed and combined view::

    def create_place(request):
        """
        Create a new crime object.
        """

        manipulator = Crime.AddManipulator()

        if request.POST:
            # If data was POSTed, we're trying to create a new Place.
            new_data = request.POST.copy()

            # Check for errors.
            errors = manipulator.get_validation_errors(new_data)

            if not errors:
                # No errors. This means we can save the data!
                manipulator.do_html2python(new_data)
                new_place = manipulator.save(new_data)

                # Redirect to the object's "edit" page. Always use a redirect
                # after POST data, so that reloads don't accidently create
                # duplicate entires, and so users don't see the confusing
                # "Repost POST data?" alert box in their browsers.
                #
                # This assumes that the creation page is at <prefix>/create/
                # and the edit page is at <prefix>/edit/<id>/
                return HttpResponseRedirect("../edit/%s/" % new_crime.id)
        else:
            # No POST, so we want a brand new form without any data or errors.
            errors = new_data = {}

        # Create the FormWrapper, template, context, response.
        form = forms.FormWrapper(manipulator, new_data, errors)
        return render_to_response('crimes/create_form.html', {
            'form': form
        })

and here's the ``create_form.html`` template::

    {% extends "base.html" %}

    {% block content %}
    <h1>Create a crime:</h1>

    {% if form.has_errors %}
      <h2>Please correct your error{{ form.error_dict|pluralize }}:</h2>
    {% endif %}

    <form method="post" action=".">
    <p>
      <label for="id_type">Type:</label> {{ form.name }}
      {% if form.type.errors %}*** {{ form.type.errors|join:", " }}{% endif %}
    </p>
    <p>
      <label for="id_location">Location:</label> {{ form.location }}
      {% if form.location.errors %}*** {{ form.location.errors|join:", " }}{% endif %}
    </p>
    <p>
      <label for="id_when_date">Date:</label> {{ form.when_date }}
      <label for="id_when_time">Time:</label> {{ form.when_time }}
      {% if form.when.errors %}*** {{ form.when.errors|join:", " }}{% endif %}
    </p>
    <input type="submit" />
    </form>
    {% endblock %}

The second two arguments to ``FormWrapper`` (``new_data`` and ``errors``)
deserve some mention.

The first is any "default" data to be used as values for the fields. Pulling
the data from ``request.POST``, as is done above, makes sure that if there are
errors, the values the user put in aren't lost. If you try the above example,
you'll see this in action.

The second argument is the error list retrieved from
``manipulator.get_validation_errors``. When passed into the ``FormWrapper``,
this gives each field an ``errors`` item (which is a list of error messages
associated with the field) as well as a ``html_error_list`` item, which is a
``<ul>`` of error messages. The above template uses these error items to
display a simple error message next to each field. The error list is saved as
an ``error_dict`` attribute of the ``FormWrapper`` object.

Using the ``ChangeManipulator``
-------------------------------

The above has covered using the ``AddManipulator`` to create a new object.
What about editing an existing one? It's shockingly similar to creating a new
one::

    def edit_crime(request, crime_id):
        # Get the place in question from the database and create a
        # ChangeManipulator at the same time.
        try:
            manipulator = Crime.ChangeManipulator(crime_id)
        except Crime.DoesNotExist:
            raise Http404

        # Grab the Crime object in question for future use.
        crime = manipulator.original_object

        if request.POST:
            new_data = request.POST.copy()
            errors = manipulator.get_validation_errors(new_data)
            if not errors:
                manipulator.do_html2python(new_data)
                manipulator.save(new_data)

                # Do a post-after-redirect to this edit page so
                # that reload works, etc.
                return HttpResponseRedirect(".")
        else:
            errors = {}
            # This makes sure the form accurate represents the
            # fields of the place.
            new_data = place.__dict__

        form = forms.FormWrapper(manipulator, new_data, errors)
        return render_to_response('crimes/edit_form.html', {
            'form': form,
            'crime': crime
        })

The only real differences are:

    * We create a ``ChangeManipulator`` instead of an ``AddManipulator``. The
      argument to a ``ChangeManipulator`` is the ID of the object to be
      changed. As you can see, the initializer will raise an
      ``ObjectDoesNotExist`` exception if the ID is invalid.

    * ``ChangeManipulator.original_object`` stores the instance of the object
      being edited.

    * We set ``new_data`` to the original object's ``__dict__``. This makes
      sure the form fields contain the current values of the object.
      ``FormWrapper`` does not modify ``new_data`` in any way, and templates
      cannot, so this is perfectly safe.

    * The above example uses a different template, so create and edit can be
      "skinned" differently if needed, but the form chunk itself is completely
      identical to the one in the create form above.

The astute programmer will notice the add and create functions are nearly
identical and could in fact be collapsed into a single view. This is left as
an exercise for said programmer.

(However, the even-more-astute programmer will take heed of the note to the
lazy above and check out the generic views documentation in the next chapter
if all she wishes to do is this type of simple create/update.)

Custom forms and manipulators
=============================

All the above is fine and dandy if you just want to use the automatically
created manipulators. But the coolness doesn't end there: You can easily
create your own custom manipulators for handling custom forms.

Custom manipulators are pretty simple. Here's a manipulator that you might use
for a "contact" form for this website::

    from django import forms

    urgency_choices = (
        (1, "Extremely urgent"),
        (2, "Urgent"),
        (3, "Normal"),
        (4, "Unimportant"),
    )

    class ContactManipulator(forms.Manipulator):
        def __init__(self):
            self.fields = (
                forms.EmailField(field_name="from", is_required=True),
                forms.TextField(field_name="subject", length=30,
                                maxlength=200, is_required=True),
                forms.SelectField(field_name="urgency",
                                  choices=urgency_choices),
                forms.LargeTextField(field_name="contents", is_required=True),
            )

A certain similarity to Django's models should be apparent. The only required
method of a custom manipulator is ``__init__`` which must define the fields
present in the manipulator. See the ``django.forms`` module for all the form
fields provided by Django.

You use this custom manipulator exactly as you would use an auto-generated
one. Here's a simple function that might drive the above form::

    def contact_form(request):
        manipulator = ContactManipulator()
        if request.POST:
            new_data = request.POST.copy()
            errors = manipulator.get_validation_errors(new_data)
            if not errors:
                manipulator.do_html2python(new_data)

                # Send e-mail using new_data here...

                return HttpResponseRedirect("/contact/thankyou/")
        else:
            errors = new_data = {}
        form = forms.FormWrapper(manipulator, new_data, errors)
        return render_to_response('contact_form.html', {'form': form})

What's next?
============

.. JKM: I don't really like this ending; I think the generic views stuff is probably considered part of the "introductory" material.  The below should probably be replaced with a lead-in to generic views.

Congratulations -- you've finished the introductory section of this book!
You'll probably want to wire the functions we've written above up to some URLs
and play with modifying them. Where you go from there is up to you; thus
endith ye olde guided toure.

Some possible directions you might travel in:

    * If you are the thorough type, you can read the rest of the book in
      order.  We've tried to organize material in a way that makes some
      sense, so have at it.

    * If you want to discover that all the code you've written so far can
      be replaced with code 90% shorter, read the next chapter about
      generic views.

    * If you want to learn about how to send email, generate RSS, PDFs,
      images, and other non-HTML content, skip to Chapter 10.

    * If you'd like to find out about all the other "goodies" that Django
      includes, those are covered in Chapters 11 through 15.

    * Chapters 16 through 18 cover some relatively esoteric tasks: integrating
      with existing databases, extending and customizing the admin interface,
      and Django's internationalization/localization framework.

    * Once you've finished an application and are ready to launch it, Chapter
      20 has all the details about how to deploy and scale Django
      applications.

    * Finally, the appendixes exhaustive reference material on
      the model API, database API, and others.

Whatever you do, we hope you'll join the Django community. Visit
http://www.djangoproject.com/ and get involved; you'll find that Django's
managed to attract one of the best open source communities around.

We'll see you there!
